# initialization:

# create input folder
shell	mkdir	input
# cd to output
shell	mkdir	output
shell 	cd	output
# create output folders
shell	mkdir	fix rst dump dumpimage dumpvtk dumpstl dumpmovie python
# step start from. weather rotate start.
tes	inputpath		string "../input/restart."
tes	ifrotate		string no
tes	iftrace			string byreduce #bynumber byreduce NONE
variable	ifappend		string no
variable	iffreeze		string yes
variable	ifpour			string no
# chunk method
variable	chunk_method		string no #x xy xyz r rz rzt NONE
# store force
variable	store_force		string no
# reset dt
variable	ifresetdt		string no
# recount dof
variable	recount_dof		string no
# trace id
if "${iftrace} == bynumber" then &
  "variable	trace_id		equal 1"

# frequency output
variable	freq_restart		equal 10
variable	freq_dump_custom	equal 1
variable	freq_dump_pair		equal 1
variable	freq_dump_image		equal 1
variable	freq_dump_other		equal 1
variable	freq_thermo		equal 1
variable	freq_fixprint		equal 1
variable	every_fixvector		equal 1
variable	freq_fixvector		equal 100
variable	freq_ave_chunk_velocity_field		equal 1  #Nevery=2, Nrepeat=6, and Nfreq=100, then 90,92,94,96,98,100
variable	repeat_ave_chunk_velocity_field	equal 1
variable	every_ave_chunk_velocity_field		equal 1
variable	freq_ave_wall		equal 1  #Nevery=2, Nrepeat=6, and Nfreq=100, then 90,92,94,96,98,100
variable	repeat_ave_wall		equal 1
variable	every_ave_wall		equal 1

# jump if restart from nonzero step
# this command specify in jobscribe "variable	rst_from equal N" be used as suffix in output file name
if		"${rst_from} > 0" then &
  "shell	cp rst/restart.${rst_from} ${inputpath}${rst_from}" &
  "read_restart ${inputpath}${rst_from}"
# number of type
variable	n_type			equal 3 #1 or 3 or  0 means no create

# gravitational acceleration
variable	g			equal 9.8

# particle diameter
variable	dp 			equal 8.3e-4		#particle diameter

# particle density
variable	den 			equal 2500

# radius of big and small atom
variable        dp_big_dp_unit		equal 1.1
variable	dp_small_dp_unit 	equal 0.9

# skin
variable	skin_dp_unit		equal 0.5

# container size
variable	ri_dp_unit		equal 37	#inner radius
variable	width_dp_unit		equal 16	#width
variable	zhi_chunk_dp_unit	equal 30	#height

# calculate ro
variable	ro_dp_unit		equal v_ri_dp_unit+v_width_dp_unit

# simulation box size
variable	zhi_box_dp_unit		equal 36

# size of region to insert atoms
variable	ri_delete_dp_unit	equal "0.5*v_dp_big_dp_unit + v_ri_dp_unit"
variable	ro_insert_dp_unit	equal "-0.5*v_dp_big_dp_unit + v_ro_dp_unit"
variable	zlo_create_dp_unit	equal 0.55
variable        zhi_create_dp_unit	equal 28.9
# pour zlo zhi
variable	zlo_pour_dp_unit	equal 0.55
variable	zhi_pour_dp_unit	equal 4.5

# contact model variable
variable	kn		equal 1.e6*v_mp*v_g/v_dp
variable	kt		equal 2/7*v_kn
variable	gamma_n		equal 317*sqrt(v_g/v_dp)
variable	gamma_t 	equal v_gamma_n/2
variable	xmu		equal 0.5
variable	ifdamp_tangent	equal 1
# number of chunk
variable	N_bin_x 	equal 50 
variable	N_bin_y 	equal 50
variable	N_bin_z 	equal 50
variable	N_bin_r 	equal v_width_dp_unit 
variable	N_bin_theta	equal 50
variable	N_bin_z		equal v_zhi_box_dp_unit/3

# salvage number
variable	Sa 		equal 2e-6

# calculate radius
variable	rp		equal v_dp/2		#particle radius

# calculate container size
variable	ro		equal v_ro_dp_unit*v_dp
variable	ri 		equal v_ri_dp_unit*v_dp
variable	zhi_chunk	equal v_zhi_chunk_dp_unit*v_dp
variable        zhi_box 	equal v_zhi_box_dp_unit*v_dp

# calculate diameter of big and small
variable	dp_big		equal v_dp_big_dp_unit*v_dp
variable	dp_small	equal v_dp_small_dp_unit*v_dp

# calculate mass
variable	mp 		equal 4/3*PI*v_rp^3*v_den

# calculate skin
variable	skin		equal v_skin_dp_unit*v_dp

# calculate size of region to create atoms
variable	ri_delete	equal v_ri_delete_dp_unit*v_dp
variable	ro_insert	equal v_ro_insert_dp_unit*v_dp
variable	zlo_create	equal v_zlo_create_dp_unit*v_dp
variable	zhi_create	equal v_zhi_create_dp_unit*v_dp

# calculate pour zlo zhi
variable	zlo_pour	equal v_zlo_pour_dp_unit*v_dp
variable	zhi_pour	equal v_zhi_pour_dp_unit*v_dp

# calculate number of bin
variable	N_total_bin 	equal v_N_bin_r*v_N_bin_theta*v_N_bin_z
variable	N_total_rz 	equal v_N_bin_r*v_N_bin_z

# calculate inner wall speed
if           "${ifrotate} == no" then "variable Sa equal 0" #change
variable	omega_in 	equal sqrt(v_Sa*v_g*(v_ro-v_ri)^3/(v_dp)^2/v_ri^2)
variable	in_velocity 	equal v_omega_in*v_ri


# define cylinder coordinate position velocity
variable	d_z_axis	atom sqrt(x*x+y*y)
variable	theta 		atom atan2(y,x)
variable	vr 		atom (vx*x+vy*y)/sqrt(x*x+y*y)
variable	vt 		atom (vx*(-y)+vy*x)/sqrt(x*x+y*y)
variable	check_vrvtvxvy 	atom v_vt*v_vt+v_vr*v_vr-vx*vx-vy*vy

# calculate chunk id
variable	rbin		atom "floor( (v_d_z_axis-v_ri)/ (v_ro-v_ri)* v_N_bin_r )"
variable	zbin		atom "floor(z/ v_zhi_chunk* v_N_bin_z)"
variable        chunk_id_r_z	atom 1+v_N_bin_r*v_zbin+v_rbin

# freeze region size
variable	zhi_freeze_dp_unit	equal 29
variable	ri_freeze_dp_unit	equal v_ri_dp_unit-v_dp_big_dp_unit/2
variable	ro_freeze_dp_unit	equal v_ro_dp_unit+v_dp_big_dp_unit/2

# calculate freeze region size
variable	zhi_freeze		equal v_zhi_freeze_dp_unit*v_dp
variable	ri_freeze		equal v_ri_freeze_dp_unit*v_dp
variable        ro_freeze		equal v_ro_freeze_dp_unit*v_dp

# lattice primitive vectors length
variable	edge_lattice		equal 2/(sqrt(3))*v_dp_big
variable	z_fraction_of_lattice	equal sqrt(3)/4

#newton
newton       on 
#timestep
timestep     0.000001

# jump to restart section
if	"${rst_from} > 0" 	then "jump SELF restart_jump"

# setting, no restart
atom_style	sphere
atom_modify	map array
boundary	f f f 
units		si

# communication, no restart
comm_style	brick
comm_modify	vel yes

# reg to define box, no restart
region		region_box cylinder z 0. 0. ${ro} 0. ${zhi_box} units box
create_box	${n_type} region_box

# contact force style, no restart
pair_style	gran/hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent}
pair_coeff	* *

# insert region
region	out_inbdy_insert 	cylinder z 0. 0. ${ri_delete} 0 ${zhi_box} units box side out
region	in_outbdy_insert 	cylinder z 0. 0. ${ro_insert} ${zlo_create} ${zhi_create} units box
region	region_ins_0		intersect 2 out_inbdy_insert in_outbdy_insert units box

# insert more region
region	out_inbdy_append 	cylinder z 0. 0. ${ri_freeze} 0 ${zhi_freeze} units box side out
region	in_outbdy_append 	cylinder z 0. 0. ${ro_freeze} 0 ${zhi_freeze} units box
region	region_append		intersect 2 out_inbdy_append in_outbdy_append units box

# extend insert region to freeze region
if "${ifappend} == no" then &
  "region	region_ins	intersect 2 out_inbdy_insert in_outbdy_insert" &
else &
  "region	region_ins	union 2 region_ins_0 region_append"

# create particle at lattice, no restart
# with scale = 1, a1 = 1 0 0, a2 = 0 1 0, and a3 = 0 0 1, no restart
lattice       bcc ${edge_lattice} origin 0 0 ${z_fraction_of_lattice}

if "${n_type} == 3" then &
  "jump SELF begin3type" &
elif "${n_type} == 1" then &
  "jump SELF begin1type" &
else &
  "print 'n_type not 3 or 1'"

jump		SELF end_create

# 3type begin
label		begin3type
create_atoms	2 region region_ins units lattice 
set		atom * type/fraction 1 0.6 12393
set		type 1 type/fraction 3 0.5 12235
# set diameter before density, otherwise mass won't fit, no restart
set		type 1 diameter ${dp_small}
set		type 2 diameter ${dp}
set		type 3 diameter ${dp_big}
set		atom * density 	${den}
# 3type end
jump		SELF end_create

# 1type begin
label		begin1type
create_atoms	1 region region_ins units lattice 
# set diameter before density, otherwise mass won't fit, no restart
set		type * diameter ${dp}
set		atom * density 	${den}

# 1type end
label		end_create

# delete atoms, no restart
region       	delete_in_small cylinder z 0. 0. ${ri_delete} 0 ${zhi_box} units box
delete_atoms 	region delete_in_small

# balance
balance 	1.0 shift xyz 20 1.1

# file, restart 0 step
write_restart	rst/restart_0


label		restart_jump

# bin size and memory
neighbor	${skin} bin
neigh_modify	delay 0

# particle force (apply force from the one need to be output and small to large)
# store force fx fy fz
fix	force_no	all store/force

# wall force to particles
if "${ifrotate} == yes" then &
  "fix	inwall		all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri} shear x ${in_velocity}" &
else &
  "fix	inwall		all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri}"
fix	force_in	all store/force
fix	outwall 	all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ro}
fix	force_in_out 	all store/force
fix	zplane_bottom 	all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zplane 0 NULL
fix	force_in_out_zplane 	all store/force

# gravity
fix	gravi 		all gravity $g vector 0.0 0.0 -1.0
fix	force_all all 	store/force

# gravitational potential
fix_modify		gravi energy yes

if "${iffreeze} == no" then "jump SELF label_end_freeze"
# freeze region
region	region_freeze	block INF INF INF INF INF ${zhi_freeze}
# freeze atoms
group	group_freeze	region region_freeze
fix	freeze_fix	group_freeze freeze

label	label_end_freeze

# pour region, block, z-axis cylinder, side = in, no restart
if "${ifpour} == no" then "jump SELF end_pour"
label	begin_pour
region	pour_region	cylinder z 0. 0. ${ro_insert} ${zlo_pour} ${zhi_pour} units box" &
fix	pour_fix	all pour 36267 1 300719 region pour_region diam one ${dp} dens 2500 2500 vol 0.55 50" &
	# run 1 step and delete
run	1	
region       	delete_in_small cylinder z 0. 0. ${ri_delete} 0 ${zhi_box} units box
delete_atoms 	region delete_in_small
label	end_pour

# ensure temperture normalize correctly as particle number change. use when pour and temperature compute ke
if "${recount_dof} == yes" then &
  "compute_modify		thermo_temp dynamic/dof yes"

# nve integration update position velocity
if "${ifresetdt} == yes" then &
  "fix	reset		all dt/reset 1 NULL 0.000001 1e-4 emax 1e-7 units box"
fix	integr		all nve/sphere


# output
# output variable
variable	t equal time

# compute chunk
# chunk
#compute		chunk_r_z all chunk/atom v_chunk_id_r_z limit ${N_total_rz} exact
# file, output by fix ave/chunk
#fix		avspatial all ave/chunk ${every_ave_chunk_velocity_field} ${repeat_ave_chunk_velocity_field} ${freq_ave_chunk_velocity_field} chunk_r_z v_vr v_vt vz file fix/file_avspatial_${rst_from}

# compute total force on particles excerted by wall 
#variable	orce_no_r atom (f_force_no[1]*x+f_force_no[2]*y)/sqrt(x*x+y*y)
#variable	force_no_theta atom (f_force_no[1]*(-y)+f_force_no[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_no all reduce sum v_force_no_r
#compute		sumupftheta_no all reduce sum v_force_no_theta
#compute		sumupfz_no all reduce sum f_force_no[3]
#
#variable	force_in_r atom (f_force_in[1]*x+f_force_in[2]*y)/sqrt(x*x+y*y)
#variable	force_in_theta atom (f_force_in[1]*(-y)+f_force_in[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_in all reduce sum v_force_in_r
#compute		sumupftheta_in all reduce sum v_force_in_theta
#compute		sumupfz_in all reduce sum f_force_in[3]
#
#variable	force_in_out_r atom (f_force_in_out[1]*x+f_force_in_out[2]*y)/sqrt(x*x+y*y)
#variable	force_in_out_theta atom (f_force_in_out[1]*(-y)+f_force_in_out[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_in_out all reduce sum v_force_in_out_r
#compute		sumupftheta_in_out all reduce sum v_force_in_out_theta
#compute		sumupfz_in_out all reduce sum f_force_in_out[3]
#
#variable	force_in_out_zplane_r atom (f_force_in_out_zplane[1]*x+f_force_in_out_zplane[2]*y)/sqrt(x*x+y*y)
#variable	force_in_out_zplane_theta atom (f_force_in_out_zplane[1]*(-y)+f_force_in_out_zplane[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_in_out_zplane all reduce sum v_force_in_out_zplane_r
#compute		sumupftheta_in_out_zplane all reduce sum v_force_in_out_zplane_theta
#compute		sumupfz_in_out_zplane all reduce sum f_force_in_out_zplane[3]
#
#variable	force_all_r atom (f_force_all[1]*x+f_force_all[2]*y)/sqrt(x*x+y*y)
#variable	force_all_theta atom (f_force_all[1]*(-y)+f_force_all[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_all all reduce sum v_force_all_r
#compute		sumupftheta_all all reduce sum v_force_all_theta
#compute		sumupfz_all all reduce sum f_force_all[3]
#
#variable	fr_in equal c_sumupfr_in-c_sumupfr_no
#variable	fr_out equal c_sumupfr_in_out-c_sumupfr_in
#variable	fr_zplane equal c_sumupfr_in_out_zplane-c_sumupfr_in_out
#variable	ftheta_in equal c_sumupftheta_in-c_sumupftheta_no
#variable	ftheta_out equal c_sumupftheta_in_out-c_sumupftheta_in
#variable	ftheta_zplane equal c_sumupftheta_in_out_zplane-c_sumupftheta_in_out
#variable	fz_in equal c_sumupfz_in-c_sumupfz_no
#variable	fz_out equal c_sumupfz_in_out-c_sumupfz_in
#variable	fz_zplane equal c_sumupfz_in_out_zplane-c_sumupfz_in_out

compute		KEt all ke
compute		KEr all erotate/sphere
variable	KEtr equal "c_KEt + c_KEr"
compute		PE all pe
variable	EKP equal "c_KEt + c_KEr + c_PE"
# compute
compute		n_contact all contact/atom
compute		m_d all property/atom mass diameter
compute		KEt_atom all ke/atom
compute		KEr_atom all erotate/sphere/atom
variable	KEtr_atom atom "c_KEt_atom + c_KEr_atom"
compute		PE_atom all pe/atom
variable        EKP_atom atom "c_KEt_atom + c_KEr_atom + c_PE_atom"

# compute specific atom id by reduce
compute         id_atom all property/atom id
compute		trace_id_reduce all reduce max c_KEt_atom c_id_atom replace 2 1

# define trace id
if "${iftrace} == byreduce" then &
  "variable	trace_id	equal c_trace_id_reduce[2]"

## define trace group, single atom or region near an atom
variable 	cutoff_dumpnb equal 0.000914
variable	id_check atom "id == v_trace_id"
variable	nb_check atom " (x-x[v_trace_id] )^2 + (y-y[v_trace_id] )^2 + (z-z[v_trace_id] )^2 < v_cutoff_dumpnb^2 "
group 		group_trace dynamic all var nb_check every 1

## file, store by fix vector and output by fix ave/time
#fix		vector_manytime all vector ${every_fixvector} v_trace_id #z[${trace_id}] vz[${trace_id}] fz[${trace_id}] c_n_contact[${trace_id}]
#variable	fixvector vector f_vector_manytime
#fix		manytime all ave/time 1 1 ${freq_fixvector} v_fixvector mode vector file fix/manytime_${rst_from} 

# file dump custom trace atoms
dump		dump_nb_maxKEatom group_trace custom ${freq_dump_custom} dump/nb_maxKEatom_${rst_from}.dump id type v_EKP_atom v_KEtr_atom c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz f_force_all[*] c_n_contact
dump_modify     dump_nb_maxKEatom append yes

# file, dump pair trace atoms
compute		p_idtype group_trace property/local patom1 patom2 ptype1 ptype2	#id_I id_J type_I type_J
compute		p_fv group_trace pair/local dist fx fy fz force			#p1,p2,p3,ft component. p4 ft magnitude. p5 p6 p7 vn. p8 p9 p10 vt. Force acting on I atom. Velocity is vi-vj
dump		dump_pair group_trace local ${freq_dump_pair} dump/pair_${rst_from}.dump index c_p_idtype[*] c_p_fv[*]
dump_modify     dump_pair append yes

##file, image jpg trace atoms
#dump		dmppic group_trace image ${freq_dump_image} dumpimage/dumpimage*.jpg type diameter size 512 512 zoom 1

# file, thermo
thermo_style	custom step atoms ke c_KEr v_KEtr v_EKP c_trace_id_reduce[2]
thermo_modify   lost error norm no
thermo		${freq_thermo}

# file, dump custom all atoms
#dump		dump_debug all custom ${freq_dump_custom} dump/debug*.dump id type v_KEtr_atom c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz c_n_contact
#dump_modify	dump_debug append no

# file, restart file
restart		${freq_restart} rst/restart.*

# file, time average of total force of wall to particles
#fix		timeav_wall_force all ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} v_t v_fr_in v_ftheta_in v_fz_in v_fr_out v_ftheta_out v_fz_out v_fr_zplane v_ftheta_zplane v_fz_zplane mode scalar ave one file fix/file_timeav_wall_${rst_from}


run 10000

variable	check_value equal v_KEtr
#label loop
#variable a loop 2000
#run 50000
#if "${check_value} < 1e-30" then "jump SELF break"
#next a
#jump SELF loop
#label break
#print "ALL DONE"

#run             30000
#start to move inwall
#define inner wall speed again
#variable        Sa equal 2e-6
#variable     omega_in equal sqrt(v_Sa*v_g*(v_ro-v_ri)^3/(v_dp)^2/v_ri^2)
#variable     in_velocity equal v_omega_in*v_ri
#fix           inwall all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} 0.5 1 zcylinder ${ri} shear x ${in_velocity}
#run             5000 upto
#file, atoms info
#dump            dmp all custom ${freq_dump_custom} dump/custom*.dump id type x y z ix iy iz vx vy vz fx fy fz omegax omegay omegaz radius diameter

#file, vtk
#dump            dmpatom all atom/vtk ${freq_dump_other} vtk/atom_*.vtk
#dump            dmpstl1 all mesh/stl ${freq_dump_other} stl/in*.stl cad1
#dump            dmpstl2 all mesh/stl ${freq_dump_other} stl/out*.stl cad2

#file, movie, have not work
#dump   m0 all movie ${freq_dump_other} dumpmovie/movie_${rst_from}.m4v type type size 640 480

#chunk method
#compute         chunk all chunk/atom bin/3d x lower 0.02 y lower 0.02 z lower 0.02 units reduced
#variable        xbin atom "floor( (x+v_ro)/ (2*v_ro)* v_N_bin_x )"
#variable        ybin atom floor((y+v_ro)/(2*v_ro)*v_N_bin_y)
#variable        zbin atom floor(z/v_zhi_chunk*v_N_bin_z)
#variable        mychunk2 atom 1+v_N_bin_z*(v_N_bin_y*v_xbin+v_ybin)+v_zbin
#compute         chunk2 all chunk/atom v_mychunk2 limit $(v_N_bin_x*v_N_bin_y*v_N_bin_z) exact 
#variable        thetabin atom floor((v_theta+PI)/(2*PI)*v_N_bin_theta)
#variable        chunk_id_rtz atom 1+v_N_bin_z*(v_N_bin_theta*v_rbin+v_thetabin)+v_zbin
#compute         chunkrtz all chunk/atom v_chunk_id_rtz limit ${N_total_bin} exact

