# v20: add pair none for removing history
#      change fix id of wall/gran to contact eleminate history
# v19: add ifallcustom in one file or separate
# v18: add ifairviscous to determine air viscous
# v17: add option for print only max atom or trackid atom to a file
# v16: put all irrelevent command to other file
# v15: use immediate variable as much as possible. i.e. use immediate variable $() if the variable only define before run
# v14: fix pour
# v13: add maxKEt in thermo file. 
#      restart file path changed
# v12: create atom method added. can choose create manually but not to use lattice
# v11: delete "then" in elif, put mp before kn
# v10: separate compute pair group for all and trace
# v9:  move timestep command to after unit defined
# v8:  compute pair group change from only tracegroup to all
# v7:  add runstep
# v6:  if append-->yes. simulation box extend, no delete when using createbox, 
#      correct unit of freeze region to box. set no output if freq_* =0
# v5:  rounding number
# v4:  store force before fix (after pair). so get pair force
# initialization:
# timer
#timer loop # loop off full sync
# set step
variable rst_from equal 0
variable runstep equal 1000
# cd to output
shell	mkdir	output
# create output folders
shell	mkdir	output/fix output/rst output/dump output/dumpimage output/dumpvtk output/dumpstl output/dumpmovie output/simulation_setting output/trace_print
# print start step
print "startstep ${rst_from}" screen no append output/simulation_setting/attribute.lammps
# step start from. weather rotate start.
variable  ts          equal 4e-7
print "timestep ${ts}" screen no append output/simulation_setting/attribute.lammps
variable  reset_history   string yes
variable	ifrotate		string no
variable	trace_id1		equal 0  # 0 means no trace
variable	trace_id2		equal 0  # 0 means no trace
variable	trace_id3		equal 0  # 0 means no trace
variable	iftrace_maxKE		string yes
variable	ifappend		string no
variable	iffreeze		string no
# create atom method
# no means no create , latt means lattice, test_collide_1wall1atom means test collide of 1 wall and 1 atom
# test_collide_twoatoms means test collide of two atoms
variable	create_atom_method			string latt 
variable	ifpour			string no
variable  pourstep    equal 100
variable  pour_number equal 240000
variable  ifdeposit   string no
variable  deposit_number equal 120000

# chunk method
variable	chunk_method		string no #x xy xyz r rz rzt NONE
# store force
variable	ifstoreforce		string no
# ifsetvelocity
variable	ifsetvelocity		string no
# reset dt
variable	ifresetdt		string no
# recount dof
if		"(${ifpour} == yes) || (${ifdeposit} == yes)" then &
  "variable	recount_dof		string yes" &
else &
  "variable	recount_dof		string no"
# frequency output
variable	freq_restart		equal 500000

variable	freq_dump_trace_image	equal 0
variable	freq_dump_all_image	equal 0

variable	freq_dump_trace_custom	equal 0
variable	freq_dump_all_custom	equal 0
variable  if_all_custom_sep string no
variable	freq_print_single_trace_max	equal 0
variable	freq_print_single_trace_1	equal 0
variable	freq_print_single_trace_2	equal 0
variable	freq_print_single_trace_3	equal 0

variable	freq_dump_trace_pair	equal 0
variable	freq_dump_all_pair	equal 0

variable	freq_dump_other		equal 0
variable	freq_thermo		equal 10000
variable	freq_fixvector		equal 0
variable	every_fixvector		equal 1
variable	freq_ave_chunk		equal 0  #Nevery=2, Nrepeat=6, and Nfreq=100, then 90,92,94,96,98,100
variable	repeat_ave_chunk	equal 1
variable	every_ave_chunk		equal 1
variable	freq_ave_wall		equal 0  #Nevery=2, Nrepeat=6, and Nfreq=100, then 90,92,94,96,98,100
variable	repeat_ave_wall		equal 1
variable	every_ave_wall		equal 1

# jump if restart from nonzero step
# this command specify in jobscribe "variable	rst_from equal N" be used as suffix in output file name
if		"${rst_from} != 0" then &
  "read_restart restart.${rst_from}"


# number of type
variable	n_type			equal 3 #1 or 3 or  0 means no create
print "n_type ${n_type}" screen no append output/simulation_setting/attribute.lammps

# if air viscous
variable	ifairviscous		string no
variable  gamma_air       equal 1

# gravitational acceleration
variable	g			equal 9.8
print "gravitational_acceleration ${g}" screen no append output/simulation_setting/attribute.lammps


# particle diameter
variable	dp 			equal 8.3e-4		#particle diameter
print "diameter ${dp}" screen no append output/simulation_setting/attribute.lammps
# calculate radius
variable	rp		equal $(v_dp/2)		#particle radius
# particle density
variable	den 			equal 2500
print "density ${den}" screen no append output/simulation_setting/attribute.lammps
# calculate mass
variable	mp 		equal $(4/3*PI*v_rp^3*v_den)
# radius of big and small atom
variable        dp_big_dp_unit		equal 1.1
variable	dp_small_dp_unit 	equal 0.9

# skin
variable	skin_dp_unit		equal 0.5

# container size simulation box size
variable	ri_dp_unit		equal 2	#inner radius
variable	width_dp_unit		equal 17	#width
variable  z_bottom_dp_unit equal 0
# calculate ro
variable	ro_dp_unit		equal $(v_ri_dp_unit+v_width_dp_unit)
# ro for box
if "${ifappend} == no" then &
  " variable r_box_dp_unit equal $(v_ro_dp_unit) " &
else &
  " variable r_box_dp_unit equal $(v_ro_dp_unit+2) "

# size of region to insert atoms
variable	ri_delete_dp_unit	equal $(0.5*v_dp_big_dp_unit + v_ri_dp_unit)
variable	ro_insert_dp_unit	equal $(-0.5*v_dp_big_dp_unit + v_ro_dp_unit)
variable	zlo_create_dp_unit	equal 0.55
variable  zhi_create_dp_unit	equal 10
# zhi for box
variable	zhi_box_dp_unit		equal $(1.1*v_zhi_create_dp_unit+1)
# chunk height
variable	zhi_chunk_dp_unit	equal $(v_zhi_box_dp_unit)	#height
# pour zlo zhi
variable	zlo_pour_dp_unit	equal $(v_zhi_box_dp_unit-2+0.999999999)
variable	zhi_pour_dp_unit	equal $(v_zhi_box_dp_unit-1)

# freeze region size
variable	zhi_freeze_dp_unit	equal 29
variable	ri_freeze_dp_unit	equal $(v_ri_dp_unit-v_dp_big_dp_unit/2)
variable	ro_freeze_dp_unit	equal $(v_ro_dp_unit+v_dp_big_dp_unit/2)

# contact model variable
variable	kn		equal $(1.e6*v_mp*v_g/v_dp)
variable	kt		equal $(2/7*v_kn)
variable	gamma_n		equal $(317*sqrt(v_g/v_dp))
variable	gamma_t 	equal $(v_gamma_n/2)
variable	xmu		equal 0.5
print "kn ${kn}" screen no append output/simulation_setting/attribute.lammps
print "kt ${kt}" screen no append output/simulation_setting/attribute.lammps
print "gamma_n ${gamma_n}" screen no append output/simulation_setting/attribute.lammps
print "gamma_t ${gamma_t}" screen no append output/simulation_setting/attribute.lammps
print "friction_coefficient ${xmu}" screen no append output/simulation_setting/attribute.lammps
variable	ifdamp_tangent	equal 1
# number of chunk
variable	N_bin_x 	equal 50 
variable	N_bin_y 	equal 50
variable	N_bin_z 	equal 50
variable	N_bin_r 	equal v_width_dp_unit 
variable	N_bin_theta	equal 50

# salvage number
variable	Sa 		equal 2e-6

# calculate container size
variable	ro		equal $(v_ro_dp_unit*v_dp)
variable	ri 		equal $(v_ri_dp_unit*v_dp)
variable  z_bottom equal $(v_z_bottom_dp_unit*v_dp)
print "ro ${ro}" screen no append output/simulation_setting/attribute.lammps
print "ri ${ri}" screen no append output/simulation_setting/attribute.lammps
print "z_bottom ${z_bottom}" screen no append output/simulation_setting/attribute.lammps

# calculate chunk height
variable	zhi_chunk	equal v_zhi_chunk_dp_unit*v_dp
# calculate simulation box size
variable r_box equal $(v_r_box_dp_unit*v_dp)
variable zhi_box 	equal $(v_zhi_box_dp_unit*v_dp)
# calculate diameter of big and small
variable	dp_big		equal $(v_dp_big_dp_unit*v_dp)
variable	dp_small	equal $(v_dp_small_dp_unit*v_dp)
print "dp_big ${dp_big}" screen no append output/simulation_setting/attribute.lammps
print "dp_small ${dp_small}" screen no append output/simulation_setting/attribute.lammps

# calculate skin
variable	skin		equal $(v_skin_dp_unit*v_dp)

# calculate size of region to create atoms
variable	ri_delete	equal $(v_ri_delete_dp_unit*v_dp)
variable	ro_insert	equal $(v_ro_insert_dp_unit*v_dp)
variable	zlo_create	equal $(v_zlo_create_dp_unit*v_dp)
variable	zhi_create	equal $(v_zhi_create_dp_unit*v_dp)

# calculate pour zlo zhi
variable	zlo_pour	equal $(v_zlo_pour_dp_unit*v_dp)
variable	zhi_pour	equal $(v_zhi_pour_dp_unit*v_dp)

# calculate number of bin
variable	N_total_bin 	equal v_N_bin_r*v_N_bin_theta*v_N_bin_z
variable	N_total_rz 	equal v_N_bin_r*v_N_bin_z

# calculate inner wall speed
if           "${ifrotate} == no" then "variable Sa equal 0" #change
variable	omega_in 	equal $(sqrt(v_Sa*v_g*(v_ro-v_ri)^3/(v_dp)^2/v_ri^2))
variable	in_velocity 	equal $(v_omega_in*v_ri)


# define cylinder coordinate position velocity
variable	d_z_axis	atom sqrt(x*x+y*y)
variable	theta 		atom atan2(y,x)
variable	vr 		atom (vx*x+vy*y)/sqrt(x*x+y*y)
variable	vt 		atom (vx*(-y)+vy*x)/sqrt(x*x+y*y)
variable	check_vrvtvxvy 	atom v_vt*v_vt+v_vr*v_vr-vx*vx-vy*vy

# calculate chunk id
variable	rbin		atom "floor( (v_d_z_axis-v_ri)/ (v_ro-v_ri)* v_N_bin_r )"
variable	zbin		atom "floor(z/ v_zhi_chunk* v_N_bin_z)"
variable        chunk_id_r_z	atom 1+v_N_bin_r*v_zbin+v_rbin


# calculate freeze region size
variable	zhi_freeze		equal $(v_zhi_freeze_dp_unit*v_dp)
variable	ri_freeze		equal $(v_ri_freeze_dp_unit*v_dp)
variable        ro_freeze		equal $(v_ro_freeze_dp_unit*v_dp)

# lattice primitive vectors length
variable	edge_lattice		equal $(2/(sqrt(3))*v_dp_big)
variable	z_fraction_of_lattice	equal $(sqrt(3)/4)

#newton
newton       on

# jump to restart section
if	"${rst_from} > 0" 	then "jump SELF restart_jump"

# setting, no restart
atom_style	sphere
atom_modify	map array
boundary	f f f 
units		si
#timestep
timestep     ${ts}
# communication, no restart
comm_style	brick
comm_modify	vel yes
processors  2 * *

# reg to define box, no restart
region		simulation_box cylinder z 0. 0. ${r_box} 0. ${zhi_box} units box

# create box
create_box	${n_type} simulation_box
# contact force style, no restart
pair_style	gran/hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent}
pair_coeff	* *

# insert region
region	out_inbdy_insert 	cylinder z 0. 0. ${ri_delete} 0 ${zhi_box} units box side out
region	in_outbdy_insert 	cylinder z 0. 0. ${ro_insert} ${zlo_create} ${zhi_create} units box
region	region_ins_0		intersect 2 out_inbdy_insert in_outbdy_insert

# insert more region
region	out_inbdy_append 	cylinder z 0. 0. ${ri_freeze} 0 ${zhi_freeze} units box side out
region	in_outbdy_append 	cylinder z 0. 0. ${ro_freeze} 0 ${zhi_freeze} units box
region	region_append		intersect 2 out_inbdy_append in_outbdy_append

# extend insert region to freeze region
if "${ifappend} == no" then &
  "region	region_ins	intersect 2 out_inbdy_insert in_outbdy_insert" &
else &
  "region	region_ins	union 2 region_ins_0 region_append"


if "${create_atom_method} == no" then &
  "jump SELF end_create"

# create particle at lattice, no restart
# with scale = 1, a1 = 1 0 0, a2 = 0 1 0, and a3 = 0 0 1, no restart
lattice       bcc ${edge_lattice} origin 0 0 ${z_fraction_of_lattice}



if "${n_type} == 3" then &
  "jump SELF begin3type" &
elif "${n_type} == 1" &
  "jump SELF begin1type" &
else &
  "print 'n_type not 3 or 1'"

# 3type begin
label		begin3type

# jump create atom by lattice
if "${create_atom_method} != latt" then &
  "jump SELF end_lattice1"

create_atoms	2 region region_ins units lattice
label   end_lattice1
set		atom * type/fraction 1 0.6 12393
set		type 1 type/fraction 3 0.5 12235
# set diameter before density, otherwise mass won't fit, no restart
set		type 1 diameter ${dp_small}
set		type 2 diameter ${dp}
set		type 3 diameter ${dp_big}
set		atom * density 	${den}
# 3type end
jump		SELF end_create

# 1type begin
label		begin1type
# jump create atom by lattice
if "${create_atom_method} != latt" then &
  "jump SELF end_lattice2"
create_atoms	1 region region_ins units lattice
label   end_lattice2

if "${create_atom_method} != test_collide_1wall1atom" then &
  "jump SELF end_test_collide_1wall1atom"
#create_atoms	1 region region_ins units lattice 
# test create 1 single atoms let inner wall collision
create_atoms 1 single $(0*0.00083) $(40*0.00083) $(0.50001*0.00083) units box
# test set velocity
set atom 1 vy $(-1.0*0.00083)
#set atom 1 vz $(-1.0*0.00083)
#set atom 2 vy $(1.0*0.00083)
# test non parallel rotate (Say contact point is c, the plane composited by vc and ac will changed over the contact time.)
set atom 1 omega 0.0 0 0
label   end_test_collide_1wall1atom

if "${create_atom_method} != test_collide_twoatoms" then &
  "jump SELF end_test_collide_twoatoms"

#create_atoms	1 region region_ins units lattice 
# test create 3 single atoms let 1 2 collision
create_atoms 1 single $(39.5*0.00083) $(0.434*0.00083) $(1*0.00083) units box
create_atoms 1 single $(39*0.00083) $(-0.434*0.00083) $(1*0.00083) units box
create_atoms 1 single $(-39*0.00083) $(0.5*0.00083) $(1*0.00083) units box

# test set velocity
set atom 1 vy $(-1.0*0.00083)
set atom 2 vy $(1.0*0.00083)

# test non parallel rotate (Say contact point is c, the plane composited by vc and ac will changed over the contact time.)
set atom 1 omega 1.0 0 0 
label   end_test_collide_twoatoms

# set diameter before density, otherwise mass won't fit, no restart
set		type * diameter ${dp}
set		atom * density 	${den}
# 1type end
label		end_create


# balance
balance 	1.0 shift yz 50 1.05

# file, restart 0 step
write_restart	output/rst/restart_0

# jump gravity ifpour and step from 0
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour5"
# gravity
fix	gravi 		all gravity $g vector 0.0 0.0 -1.0
if "${ifstoreforce} == yes" then "fix	force_all	all store/force"
# gravitational potential
fix_modify		gravi energy yes
label	end_pour5
# pour region, block, z-axis cylinder, side = in, no restart
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour"
label	begin_pour
region	pour_region	cylinder z 0. 0. ${ro_insert} ${zlo_pour} ${zhi_pour} units box
fix	pour_fix	all pour ${pour_number} 1 300719 region pour_region diam poly 3 $(0.9*v_dp) 0.3 $(v_dp) 0.4 $(1.1*v_dp) 0.3 dens 2500 2500 vol 100000 1
label	end_pour

# deposit region, block, z-axis cylinder, side = in, no restart
if "${ifdeposit} == no || ${rst_from} != 0" then "jump SELF end_deposit"

label	begin_deposit
region  deposit_in_region_sideout cylinder z 0. 0. ${ri_delete} ${zlo_pour} ${zhi_pour} units box side out
region  deposit_out_region	cylinder z 0. 0. ${ro_insert} ${zlo_pour} ${zhi_pour} units box
region  deposit_region intersect 2 deposit_in_region_sideout deposit_out_region

if "${n_type} == 3" then &
  "jump SELF begin3type_deposit" &
elif "${n_type} == 1" &
  "jump SELF begin1type_deposit" &
else &
  "print 'n_type not 3 or 1'"

# 1type deposit begin
label		begin1type_deposit

fix	deposit_type1_fix	all deposit ${v_deposit_number} 1 1 29494 region deposit_region near ${dp} units box
set		type * diameter ${dp}
set		atom * density 	${den}
jump SELF end_deposit

# 3type deposit begin
label		begin3type_deposit
# set diameter before density, otherwise mass won't fit, no restart

variable number_type1 equal $(0.3*v_deposit_number)
variable number_type2 equal $(0.4*v_deposit_number)
variable number_type3 equal $(0.3*v_deposit_number)
fix	deposit_type1_fix	all deposit ${number_type1} 1 4 29494 region deposit_region near ${dp_big} units box
fix	deposit_type2_fix	all deposit ${number_type2} 2 3 12235 region deposit_region near ${dp_big} units box
fix	deposit_type3_fix	all deposit ${number_type3} 3 4 777 region deposit_region near ${dp_big} units box
set		type 1 diameter ${dp_small}
set		type 2 diameter ${dp}
set		type 3 diameter ${dp_big}
set		atom * density 	${den}
jump SELF end_deposit

label	end_deposit

label		restart_jump

if "${reset_history} == no || ${rst_from} == 0" then &
  "jump SELF reset_pair_history_end"
pair_style none
run 1
pair_style	gran/hooke/history ${kn} $(7/2*v_kn) ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent}
pair_coeff	* *
label   reset_pair_history_end

# bin size and memory
neighbor	${skin} bin
neigh_modify	delay 0

# particle force (apply force from the one need to be output and small to large)
# store force fx fy fz
if "${ifstoreforce} == yes" then "fix	force_pair	all store/force"

# wall force to particles
# inner wall
# define inner wall, if pour then define inner wall after pouring
if "${ifpour} == yes && ${rst_from} == 0" then "jump SELF end_pour6_innerwall"
if "${ifrotate} == yes" then &
  "fix	inwall		all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri} shear x ${in_velocity}" &
else &
  "fix	inwall		all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri}"
label	end_pour6_innerwall

# other wall
if "${ifstoreforce} == yes" then "fix	force_in	all store/force"

fix	outwall 	all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ro}
if "${ifstoreforce} == yes" then "fix	force_in_out	all store/force"
fix	zplane_bottom 	all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zplane ${z_bottom} NULL
if "${ifstoreforce} == yes" then "fix	force_in_out_zplane	all store/force"



# jump gravity ifpour and step from 0
if "${ifpour} == yes && ${rst_from} == 0" then "jump SELF end_pour4"
# gravity
fix	gravi 		all gravity $g vector 0.0 0.0 -1.0
if "${ifstoreforce} == yes" then "fix	force_all	all store/force"
# gravitational potential
fix_modify		gravi energy yes
label	end_pour4

if "${iffreeze} == no" then "jump SELF label_end_freeze"
# freeze region
region	region_freeze	block INF INF INF INF INF ${zhi_freeze} units box
# freeze atoms, but freeze_group not to be re-define when restart
if      "${rst_from} == 0"	then "group	freeze_group	region region_freeze"
if	"${ifsetvelocity} == yes"	then "velocity freeze_group set 0 0 0"
fix	freeze_fix	freeze_group freeze

label	label_end_freeze

# air viscous
if "${ifairviscous} == no" then &
  "jump SELF end_airviscous"
print "gamma_air ${gamma_air}" screen no append output/simulation_setting/attribute.lammps
fix airviscous all viscous $(v_gamma_air*v_mp)
label   end_airviscous

# ensure temperture normalize correctly as particle number change. use when pour and temperature compute ke
if "${recount_dof} == yes" then &
  "compute_modify		thermo_temp dynamic/dof yes"

# nve integration update position velocity
if "${ifresetdt} == yes" then &
  "fix	reset		all dt/reset 1 NULL 0.000001 1e-4 emax 1e-7 units box"
fix	integr		all nve/sphere


# output
# output variable
variable	t equal time

# compute chunk
if "${freq_ave_chunk} == 0" then "jump SELF skip_ave_chunk"
compute		chunk_r_z all chunk/atom v_chunk_id_r_z limit ${N_total_rz} exact
# file, output by fix ave/chunk
if "${freq_ave_chunk} == 0" then "jump SELF skip_ave_chunk"
fix		avspatial all ave/chunk ${every_ave_chunk} ${repeat_ave_chunk} ${freq_ave_chunk} chunk_r_z v_vr v_vt vz file output/fix/file_avspatial_${rst_from}
label skip_ave_chunk
# compute total force on particles excerted by wall 
#variable	orce_no_r atom (f_force_pair[1]*x+f_force_pair[2]*y)/sqrt(x*x+y*y)
#variable	force_pair_theta atom (f_force_pair[1]*(-y)+f_force_pair[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_no all reduce sum v_force_pair_r
#compute		sumupftheta_no all reduce sum v_force_pair_theta
#compute		sumupfz_no all reduce sum f_force_pair[3]
#
#variable	force_in_r atom (f_force_in[1]*x+f_force_in[2]*y)/sqrt(x*x+y*y)
#variable	force_in_theta atom (f_force_in[1]*(-y)+f_force_in[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_in all reduce sum v_force_in_r
#compute		sumupftheta_in all reduce sum v_force_in_theta
#compute		sumupfz_in all reduce sum f_force_in[3]
#
#variable	force_in_out_r atom (f_force_in_out[1]*x+f_force_in_out[2]*y)/sqrt(x*x+y*y)
#variable	force_in_out_theta atom (f_force_in_out[1]*(-y)+f_force_in_out[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_in_out all reduce sum v_force_in_out_r
#compute		sumupftheta_in_out all reduce sum v_force_in_out_theta
#compute		sumupfz_in_out all reduce sum f_force_in_out[3]
#
#variable	force_in_out_zplane_r atom (f_force_in_out_zplane[1]*x+f_force_in_out_zplane[2]*y)/sqrt(x*x+y*y)
#variable	force_in_out_zplane_theta atom (f_force_in_out_zplane[1]*(-y)+f_force_in_out_zplane[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_in_out_zplane all reduce sum v_force_in_out_zplane_r
#compute		sumupftheta_in_out_zplane all reduce sum v_force_in_out_zplane_theta
#compute		sumupfz_in_out_zplane all reduce sum f_force_in_out_zplane[3]
#
#variable	force_all_r atom (f_force_all[1]*x+f_force_all[2]*y)/sqrt(x*x+y*y)
#variable	force_all_theta atom (f_force_all[1]*(-y)+f_force_all[2]*x)/sqrt(x*x+y*y)
#compute		sumupfr_all all reduce sum v_force_all_r
#compute		sumupftheta_all all reduce sum v_force_all_theta
#compute		sumupfz_all all reduce sum f_force_all[3]
#
#variable	fr_in equal c_sumupfr_in-c_sumupfr_no
#variable	fr_out equal c_sumupfr_in_out-c_sumupfr_in
#variable	fr_zplane equal c_sumupfr_in_out_zplane-c_sumupfr_in_out
#variable	ftheta_in equal c_sumupftheta_in-c_sumupftheta_no
#variable	ftheta_out equal c_sumupftheta_in_out-c_sumupftheta_in
#variable	ftheta_zplane equal c_sumupftheta_in_out_zplane-c_sumupftheta_in_out
#variable	fz_in equal c_sumupfz_in-c_sumupfz_no
#variable	fz_out equal c_sumupfz_in_out-c_sumupfz_in
#variable	fz_zplane equal c_sumupfz_in_out_zplane-c_sumupfz_in_out

compute		KEt all ke
compute		KEr all erotate/sphere
variable	KEtr equal "c_KEt + c_KEr"
compute		PE all pe
variable	EKP equal "c_KEt + c_KEr + c_PE"
# compute
compute		n_contact all contact/atom
compute		m_d all property/atom mass diameter
compute		KEt_atom all ke/atom
compute		KEr_atom all erotate/sphere/atom
variable	KEtr_atom atom "c_KEt_atom + c_KEr_atom"
compute		PE_atom all pe/atom
variable        EKP_atom atom "c_KEt_atom + c_KEr_atom + c_PE_atom"

# compute id
compute         id_atom all property/atom id
# define nbd radius
variable 	cutoff_dumpnb equal 0.000914
# compute specific atom id by reduce
compute		id_maxKEt all reduce max c_id_atom c_KEt_atom replace 1 2
compute		id_maxKEr all reduce max c_id_atom c_KEr_atom replace 1 2
compute		id_maxKEtr all reduce max c_id_atom v_KEtr_atom replace 1 2

# define trace id
variable	check_nbid1 atom false
variable	check_nbid2 atom false
variable	check_nbid3 atom false
variable	check_nbmaxKEt atom false
variable	check_nbmaxKEr atom false
variable	check_nbmaxKEtr atom false
# trace id maxKE
if "${iftrace_maxKE} == no" then &
  "jump SELF end_tracemaxKE"
variable	trace_id_KEt equal c_id_maxKEt[1]
variable	trace_id_KEr equal c_id_maxKEr[1]
variable	trace_id_KEtr equal c_id_maxKEtr[1]

## define trace group, single atom or region near an atom
variable	check_nbmaxKEt atom " (x-x[v_trace_id_KEt] )^2 + (y-y[v_trace_id_KEt] )^2 + (z-z[v_trace_id_KEt] )^2 < v_cutoff_dumpnb^2 "
variable	check_nbmaxKEr atom " (x-x[v_trace_id_KEr] )^2 + (y-y[v_trace_id_KEr] )^2 + (z-z[v_trace_id_KEr] )^2 < v_cutoff_dumpnb^2 "
variable	check_nbmaxKEtr atom " (x-x[v_trace_id_KEtr] )^2 + (y-y[v_trace_id_KEtr] )^2 + (z-z[v_trace_id_KEtr] )^2 < v_cutoff_dumpnb^2 "
label		end_tracemaxKE
# trace id1 
if "${trace_id1} == 0" then &
  "jump SELF end_traceid1"
## define trace group, single atom or region near an atom
variable	check_nbid1 atom " (x-x[v_trace_id1] )^2 + (y-y[v_trace_id1] )^2 + (z-z[v_trace_id1] )^2 < v_cutoff_dumpnb^2 "
label		end_traceid1
# trace id2 
if "${trace_id2} == 0" then &
  "jump SELF end_traceid2"
## define trace group, single atom or region near an atom
variable	check_nbid2 atom " (x-x[v_trace_id2] )^2 + (y-y[v_trace_id2] )^2 + (z-z[v_trace_id2] )^2 < v_cutoff_dumpnb^2 "
label		end_traceid2
# trace id3
if "${trace_id3} == 0" then &
  "jump SELF end_traceid3"
## define trace group, single atom or region near an atom
variable	check_nbid3 atom " (x-x[v_trace_id3] )^2 + (y-y[v_trace_id3] )^2 + (z-z[v_trace_id3] )^2 < v_cutoff_dumpnb^2 "
label		end_traceid3



# file, store by fix vector and output by fix ave/time
if "${freq_fixvector} == 0" then "jump SELF skip_fixvector"
fix		vector_manytime all vector ${every_fixvector} v_trace_id #z[${trace_id}] vz[${trace_id}] fz[${trace_id}] c_n_contact[${trace_id}]
variable	fixvector vector f_vector_manytime
if "${freq_fixvector} == 0" then "jump SELF skip_fixvector"
fix		manytime all ave/time 1 1 ${freq_fixvector} v_fixvector mode vector file output/fix/manytime_${rst_from} 
label skip_fixvector



# file print trace atom_max
if "${freq_print_single_trace_max} == 0" then "jump SELF skip_print_single_trace_max"

variable print_trace_max_scalar_id equal id[v_trace_id_KEt]
variable print_trace_max_scalar_type equal type[v_trace_id_KEt]

compute max_radius all property/atom radius
compute max_omegax all property/atom omegax
compute max_omegay all property/atom omegay
compute max_omegaz all property/atom omegaz
compute max_tqx all property/atom tqx
compute max_tqy all property/atom tqy
compute max_tqz all property/atom tqz
variable print_trace_max_scalar_radius equal c_max_radius[v_trace_id_KEt]
variable print_trace_max_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id_KEt]
variable print_trace_max_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id_KEt]
variable print_trace_max_scalar_x equal x[v_trace_id_KEt]
variable print_trace_max_scalar_y equal y[v_trace_id_KEt]
variable print_trace_max_scalar_z equal z[v_trace_id_KEt]
variable print_trace_max_scalar_vx equal vx[v_trace_id_KEt]
variable print_trace_max_scalar_vy equal vy[v_trace_id_KEt]
variable print_trace_max_scalar_vz equal vz[v_trace_id_KEt]
variable print_trace_max_scalar_fx equal fx[v_trace_id_KEt]
variable print_trace_max_scalar_fy equal fy[v_trace_id_KEt]
variable print_trace_max_scalar_fz equal fz[v_trace_id_KEt]
variable print_trace_max_scalar_omegax equal c_max_omegax[v_trace_id_KEt]
variable print_trace_max_scalar_omegay equal c_max_omegay[v_trace_id_KEt]
variable print_trace_max_scalar_omegaz equal c_max_omegaz[v_trace_id_KEt]
variable print_trace_max_scalar_tqx equal c_max_tqx[v_trace_id_KEt]
variable print_trace_max_scalar_tqy equal c_max_tqy[v_trace_id_KEt]
variable print_trace_max_scalar_tqz equal c_max_tqz[v_trace_id_KEt]


fix print_max_id all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_id)" screen no append output/trace_print/trace_atom_max_id.txt
fix print_max_type all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_type)" screen no append output/trace_print/trace_atom_max_type.txt
fix print_max_radius all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_radius)" screen no append output/trace_print/trace_atom_max_radius.txt
fix print_max_c_KEt_atom all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_c_KEt_atom)" screen no append output/trace_print/trace_atom_max_c_KEt_atom.txt
fix print_max_c_KEr_atom all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_c_KEr_atom)" screen no append output/trace_print/trace_atom_max_c_KEr_atom.txt
fix print_max_x all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_x)" screen no append output/trace_print/trace_atom_max_x.txt
fix print_max_y all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_y)" screen no append output/trace_print/trace_atom_max_y.txt
fix print_max_z all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_z)" screen no append output/trace_print/trace_atom_max_z.txt
fix print_max_vx all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_vx)" screen no append output/trace_print/trace_atom_max_vx.txt
fix print_max_vy all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_vy)" screen no append output/trace_print/trace_atom_max_vy.txt
fix print_max_vz all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_vz)" screen no append output/trace_print/trace_atom_max_vz.txt
fix print_max_fx all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_fx)" screen no append output/trace_print/trace_atom_max_fx.txt
fix print_max_fy all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_fy)" screen no append output/trace_print/trace_atom_max_fy.txt
fix print_max_fz all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_fz)" screen no append output/trace_print/trace_atom_max_fz.txt
fix print_max_omegax all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_omegax)" screen no append output/trace_print/trace_atom_max_omegax.txt
fix print_max_omegay all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_omegay)" screen no append output/trace_print/trace_atom_max_omegay.txt
fix print_max_omegaz all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_omegaz)" screen no append output/trace_print/trace_atom_max_omegaz.txt
fix print_max_tqx all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_tqx)" screen no append output/trace_print/trace_atom_max_tqx.txt
fix print_max_tqy all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_tqy)" screen no append output/trace_print/trace_atom_max_tqy.txt
fix print_max_tqz all print ${freq_print_single_trace_max} "$(v_print_trace_max_scalar_tqz)" screen no append output/trace_print/trace_atom_max_tqz.txt

label skip_print_single_trace_max

# file print trace atom_1
if "${freq_print_single_trace_1} == 0" then "jump SELF skip_print_single_trace_1"

variable print_trace_1_scalar_id equal id[v_trace_id1]
variable print_trace_1_scalar_type equal type[v_trace_id1]

compute 1_radius all property/atom radius
compute 1_omegax all property/atom omegax
compute 1_omegay all property/atom omegay
compute 1_omegaz all property/atom omegaz
compute 1_tqx all property/atom tqx
compute 1_tqy all property/atom tqy
compute 1_tqz all property/atom tqz
variable print_trace_1_scalar_radius equal c_1_radius[v_trace_id1]
variable print_trace_1_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id1]
variable print_trace_1_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id1]
variable print_trace_1_scalar_x equal x[v_trace_id1]
variable print_trace_1_scalar_y equal y[v_trace_id1]
variable print_trace_1_scalar_z equal z[v_trace_id1]
variable print_trace_1_scalar_vx equal vx[v_trace_id1]
variable print_trace_1_scalar_vy equal vy[v_trace_id1]
variable print_trace_1_scalar_vz equal vz[v_trace_id1]
variable print_trace_1_scalar_fx equal fx[v_trace_id1]
variable print_trace_1_scalar_fy equal fy[v_trace_id1]
variable print_trace_1_scalar_fz equal fz[v_trace_id1]
variable print_trace_1_scalar_omegax equal c_1_omegax[v_trace_id1]
variable print_trace_1_scalar_omegay equal c_1_omegay[v_trace_id1]
variable print_trace_1_scalar_omegaz equal c_1_omegaz[v_trace_id1]
variable print_trace_1_scalar_tqx equal c_1_tqx[v_trace_id1]
variable print_trace_1_scalar_tqy equal c_1_tqy[v_trace_id1]
variable print_trace_1_scalar_tqz equal c_1_tqz[v_trace_id1]

fix print_1_id all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_id)" screen no append output/trace_print/trace_atom_${trace_id1}_id.txt
fix print_1_type all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_type)" screen no append output/trace_print/trace_atom_${trace_id1}_type.txt
fix print_1_radius all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_radius)" screen no append output/trace_print/trace_atom_${trace_id1}_radius.txt
fix print_1_c_KEt_atom all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_c_KEt_atom)" screen no append output/trace_print/trace_atom_${trace_id1}_c_KEt_atom.txt
fix print_1_c_KEr_atom all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_c_KEr_atom)" screen no append output/trace_print/trace_atom_${trace_id1}_c_KEr_atom.txt
fix print_1_x all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_x)" screen no append output/trace_print/trace_atom_${trace_id1}_x.txt
fix print_1_y all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_y)" screen no append output/trace_print/trace_atom_${trace_id1}_y.txt
fix print_1_z all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_z)" screen no append output/trace_print/trace_atom_${trace_id1}_z.txt
fix print_1_vx all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_vx)" screen no append output/trace_print/trace_atom_${trace_id1}_vx.txt
fix print_1_vy all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_vy)" screen no append output/trace_print/trace_atom_${trace_id1}_vy.txt
fix print_1_vz all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_vz)" screen no append output/trace_print/trace_atom_${trace_id1}_vz.txt
fix print_1_fx all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_fx)" screen no append output/trace_print/trace_atom_${trace_id1}_fx.txt
fix print_1_fy all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_fy)" screen no append output/trace_print/trace_atom_${trace_id1}_fy.txt
fix print_1_fz all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_fz)" screen no append output/trace_print/trace_atom_${trace_id1}_fz.txt
fix print_1_omegax all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_omegax)" screen no append output/trace_print/trace_atom_${trace_id1}_omegax.txt
fix print_1_omegay all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_omegay)" screen no append output/trace_print/trace_atom_${trace_id1}_omegay.txt
fix print_1_omegaz all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_omegaz)" screen no append output/trace_print/trace_atom_${trace_id1}_omegaz.txt
fix print_1_tqx all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_tqx)" screen no append output/trace_print/trace_atom_${trace_id1}_tqx.txt
fix print_1_tqy all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_tqy)" screen no append output/trace_print/trace_atom_${trace_id1}_tqy.txt
fix print_1_tqz all print ${freq_print_single_trace_1} "$(v_print_trace_1_scalar_tqz)" screen no append output/trace_print/trace_atom_${trace_id1}_tqz.txt

label skip_print_single_trace_1


# file print trace atom_2
if "${freq_print_single_trace_2} == 0" then "jump SELF skip_print_single_trace_2"

variable print_trace_2_scalar_id equal id[v_trace_id2]
variable print_trace_2_scalar_type equal type[v_trace_id2]

compute 2_radius all property/atom radius
compute 2_omegax all property/atom omegax
compute 2_omegay all property/atom omegay
compute 2_omegaz all property/atom omegaz
compute 2_tqx all property/atom tqx
compute 2_tqy all property/atom tqy
compute 2_tqz all property/atom tqz
variable print_trace_2_scalar_radius equal c_2_radius[v_trace_id2]
variable print_trace_2_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id2]
variable print_trace_2_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id2]
variable print_trace_2_scalar_x equal x[v_trace_id2]
variable print_trace_2_scalar_y equal y[v_trace_id2]
variable print_trace_2_scalar_z equal z[v_trace_id2]
variable print_trace_2_scalar_vx equal vx[v_trace_id2]
variable print_trace_2_scalar_vy equal vy[v_trace_id2]
variable print_trace_2_scalar_vz equal vz[v_trace_id2]
variable print_trace_2_scalar_fx equal fx[v_trace_id2]
variable print_trace_2_scalar_fy equal fy[v_trace_id2]
variable print_trace_2_scalar_fz equal fz[v_trace_id2]
variable print_trace_2_scalar_omegax equal c_2_omegax[v_trace_id2]
variable print_trace_2_scalar_omegay equal c_2_omegay[v_trace_id2]
variable print_trace_2_scalar_omegaz equal c_2_omegaz[v_trace_id2]
variable print_trace_2_scalar_tqx equal c_2_tqx[v_trace_id2]
variable print_trace_2_scalar_tqy equal c_2_tqy[v_trace_id2]
variable print_trace_2_scalar_tqz equal c_2_tqz[v_trace_id2]

fix print_2_id all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_id)" screen no append output/trace_print/trace_atom_${trace_id2}_id.txt
fix print_2_type all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_type)" screen no append output/trace_print/trace_atom_${trace_id2}_type.txt
fix print_2_radius all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_radius)" screen no append output/trace_print/trace_atom_${trace_id2}_radius.txt
fix print_2_c_KEt_atom all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_c_KEt_atom)" screen no append output/trace_print/trace_atom_${trace_id2}_c_KEt_atom.txt
fix print_2_c_KEr_atom all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_c_KEr_atom)" screen no append output/trace_print/trace_atom_${trace_id2}_c_KEr_atom.txt
fix print_2_x all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_x)" screen no append output/trace_print/trace_atom_${trace_id2}_x.txt
fix print_2_y all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_y)" screen no append output/trace_print/trace_atom_${trace_id2}_y.txt
fix print_2_z all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_z)" screen no append output/trace_print/trace_atom_${trace_id2}_z.txt
fix print_2_vx all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_vx)" screen no append output/trace_print/trace_atom_${trace_id2}_vx.txt
fix print_2_vy all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_vy)" screen no append output/trace_print/trace_atom_${trace_id2}_vy.txt
fix print_2_vz all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_vz)" screen no append output/trace_print/trace_atom_${trace_id2}_vz.txt
fix print_2_fx all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_fx)" screen no append output/trace_print/trace_atom_${trace_id2}_fx.txt
fix print_2_fy all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_fy)" screen no append output/trace_print/trace_atom_${trace_id2}_fy.txt
fix print_2_fz all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_fz)" screen no append output/trace_print/trace_atom_${trace_id2}_fz.txt
fix print_2_omegax all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_omegax)" screen no append output/trace_print/trace_atom_${trace_id2}_omegax.txt
fix print_2_omegay all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_omegay)" screen no append output/trace_print/trace_atom_${trace_id2}_omegay.txt
fix print_2_omegaz all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_omegaz)" screen no append output/trace_print/trace_atom_${trace_id2}_omegaz.txt
fix print_2_tqx all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_tqx)" screen no append output/trace_print/trace_atom_${trace_id2}_tqx.txt
fix print_2_tqy all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_tqy)" screen no append output/trace_print/trace_atom_${trace_id2}_tqy.txt
fix print_2_tqz all print ${freq_print_single_trace_2} "$(v_print_trace_2_scalar_tqz)" screen no append output/trace_print/trace_atom_${trace_id2}_tqz.txt

label skip_print_single_trace_2


# file print trace atom_3
if "${freq_print_single_trace_3} == 0" then "jump SELF skip_print_single_trace_3"

variable print_trace_3_scalar_id equal id[v_trace_id3]
variable print_trace_3_scalar_type equal type[v_trace_id3]

compute 3_radius all property/atom radius
compute 3_omegax all property/atom omegax
compute 3_omegay all property/atom omegay
compute 3_omegaz all property/atom omegaz
compute 3_tqx all property/atom tqx
compute 3_tqy all property/atom tqy
compute 3_tqz all property/atom tqz
variable print_trace_3_scalar_radius equal c_3_radius[v_trace_id3]
variable print_trace_3_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id3]
variable print_trace_3_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id3]
variable print_trace_3_scalar_x equal x[v_trace_id3]
variable print_trace_3_scalar_y equal y[v_trace_id3]
variable print_trace_3_scalar_z equal z[v_trace_id3]
variable print_trace_3_scalar_vx equal vx[v_trace_id3]
variable print_trace_3_scalar_vy equal vy[v_trace_id3]
variable print_trace_3_scalar_vz equal vz[v_trace_id3]
variable print_trace_3_scalar_fx equal fx[v_trace_id3]
variable print_trace_3_scalar_fy equal fy[v_trace_id3]
variable print_trace_3_scalar_fz equal fz[v_trace_id3]
variable print_trace_3_scalar_omegax equal c_3_omegax[v_trace_id3]
variable print_trace_3_scalar_omegay equal c_3_omegay[v_trace_id3]
variable print_trace_3_scalar_omegaz equal c_3_omegaz[v_trace_id3]
variable print_trace_3_scalar_tqx equal c_3_tqx[v_trace_id3]
variable print_trace_3_scalar_tqy equal c_3_tqy[v_trace_id3]
variable print_trace_3_scalar_tqz equal c_3_tqz[v_trace_id3]

fix print_3_id all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_id)" screen no append output/trace_print/trace_atom_${trace_id3}_id.txt
fix print_3_type all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_type)" screen no append output/trace_print/trace_atom_${trace_id3}_type.txt
fix print_3_radius all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_radius)" screen no append output/trace_print/trace_atom_${trace_id3}_radius.txt
fix print_3_c_KEt_atom all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_c_KEt_atom)" screen no append output/trace_print/trace_atom_${trace_id3}_c_KEt_atom.txt
fix print_3_c_KEr_atom all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_c_KEr_atom)" screen no append output/trace_print/trace_atom_${trace_id3}_c_KEr_atom.txt
fix print_3_x all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_x)" screen no append output/trace_print/trace_atom_${trace_id3}_x.txt
fix print_3_y all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_y)" screen no append output/trace_print/trace_atom_${trace_id3}_y.txt
fix print_3_z all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_z)" screen no append output/trace_print/trace_atom_${trace_id3}_z.txt
fix print_3_vx all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_vx)" screen no append output/trace_print/trace_atom_${trace_id3}_vx.txt
fix print_3_vy all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_vy)" screen no append output/trace_print/trace_atom_${trace_id3}_vy.txt
fix print_3_vz all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_vz)" screen no append output/trace_print/trace_atom_${trace_id3}_vz.txt
fix print_3_fx all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_fx)" screen no append output/trace_print/trace_atom_${trace_id3}_fx.txt
fix print_3_fy all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_fy)" screen no append output/trace_print/trace_atom_${trace_id3}_fy.txt
fix print_3_fz all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_fz)" screen no append output/trace_print/trace_atom_${trace_id3}_fz.txt
fix print_3_omegax all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_omegax)" screen no append output/trace_print/trace_atom_${trace_id3}_omegax.txt
fix print_3_omegay all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_omegay)" screen no append output/trace_print/trace_atom_${trace_id3}_omegay.txt
fix print_3_omegaz all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_omegaz)" screen no append output/trace_print/trace_atom_${trace_id3}_omegaz.txt
fix print_3_tqx all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_tqx)" screen no append output/trace_print/trace_atom_${trace_id3}_tqx.txt
fix print_3_tqy all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_tqy)" screen no append output/trace_print/trace_atom_${trace_id3}_tqy.txt
fix print_3_tqz all print ${freq_print_single_trace_3} "$(v_print_trace_3_scalar_tqz)" screen no append output/trace_print/trace_atom_${trace_id3}_tqz.txt

label skip_print_single_trace_3

variable	check_nb_all atom v_check_nbid1||v_check_nbid2||v_check_nbid3||v_check_nbmaxKEt||v_check_nbmaxKEr||v_check_nbmaxKEtr
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour3"
run 1
label	end_pour3
if "${ifdeposit} == no || ${rst_from} != 0" then "jump SELF end_deposit2"
run 1
label	end_deposit2
group 		group_nb_all dynamic all var check_nb_all every 1

# file dump custom trace atoms
if "${freq_dump_trace_custom} == 0" then "jump SELF skip_dump_trace_custom"
dump		dump_nb_maxKEatom group_nb_all custom ${freq_dump_trace_custom} output/dump/nb_maxKEatom_${rst_from}.dump id type radius c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz v_EKP_atom f_force_all[*] f_force_pair[*] c_n_contact v_check_nb_all v_KEtr_atom
dump_modify     dump_nb_maxKEatom append yes format float %.16g
label skip_dump_trace_custom
# file, dump custom all atoms
if "${freq_dump_all_custom} == 0" then "jump SELF skip_dump_all_custom"

if "${if_all_custom_sep} == no" then "jump SELF skip_dump_all_custom_sepfile"
dump		dump_debug all custom ${freq_dump_all_custom} output/dump/all*.dump id type radius c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz v_EKP_atom f_force_all[*] f_force_pair[*] c_n_contact v_check_nb_all v_KEtr_atom
dump_modify	dump_debug append no format float %.16g
label skip_dump_all_custom_sepfile

if "${if_all_custom_sep} == yes" then "jump SELF skip_dump_all_custom_allinonefile"
dump		dump_debug all custom ${freq_dump_all_custom} output/dump/all_${rst_from}.dump id type radius c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz v_EKP_atom f_force_all[*] f_force_pair[*] c_n_contact v_check_nb_all v_KEtr_atom
dump_modify	dump_debug append no format float %.16g
label skip_dump_all_custom_allinonefile
label skip_dump_all_custom

# compute pair trace atoms
if "${freq_dump_trace_pair} == 0" then "jump SELF skip_dump_trace_pair"
compute		p_idtype_trace group_nb_all property/local patom1 patom2 ptype1 ptype2	#id_I id_J type_I type_J
compute		p_fv_trace group_nb_all pair/local dist fx fy fz force p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 	#p1,p2,p3,ft component. p4 ft magnitude. p5 p6 p7 vn. p8 p9 p10 vt. Force acting on I atom. Velocity is vi-vj
label skip_compute_pair
# file, pair trace atoms
dump		dump_trace_pair group_nb_all local ${freq_dump_trace_pair} output/dump/pair_trace_${rst_from}.dump index c_p_idtype_trace[*] c_p_fv_trace[*]
dump_modify     dump_trace_pair append yes
label skip_dump_trace_pair

# compute pair all atoms
if "${freq_dump_all_pair} == 0" then "jump SELF skip_dump_all_pair"
compute		p_idtype_all all property/local patom1 patom2 ptype1 ptype2	#id_I id_J type_I type_J
compute		p_fv_all all pair/local dist fx fy fz force p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 	#p1,p2,p3,ft component. p4 ft magnitude. p5 p6 p7 vn. p8 p9 p10 vt. Force acting on I atom. Velocity is vi-vj
label skip_compute_pair
# file, pair all atoms
dump		dump_all_pair all local ${freq_dump_all_pair} output/dump/pair_all_${rst_from}.dump index c_p_idtype_all[*] c_p_fv_all[*]
dump_modify     dump_all_pair append yes
label skip_dump_all_pair

#file, image jpg trace atoms
if "${freq_dump_trace_image} == 0" then "jump SELF skip_dump_trace_image"
dump		dump_image_trace group_nb_all image ${freq_dump_trace_image} output/dumpimage/trace_image*.jpg type diameter size 512 512 zoom 1
label skip_dump_trace_image

#file, image jpg all atoms
if "${freq_dump_all_image} == 0" then "jump SELF skip_dump_all_image"
dump		dump_image_all all image ${freq_dump_all_image} output/dumpimage/all_image*.jpg type diameter size 512 512 zoom 1
label skip_dump_all_image

# file, thermo
thermo_style	custom step atoms ke c_KEr v_KEtr v_EKP c_id_maxKEt[1] c_id_maxKEt[2]
thermo_modify   lost error norm no
if "${freq_thermo} == 0" then "jump SELF skip_thermo"
thermo		${freq_thermo}
label skip_thermo

# file, restart file
if "${freq_restart} == 0" then "jump SELF skip_restart"
restart		${freq_restart} output/rst/restart.*
label skip_restart

# file, time average of total force of wall to particles
if "${freq_ave_wall} == 0" then "jump SELF skip_ave_wall"
fix		timeav_wall_force all ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} v_t v_fr_in v_ftheta_in v_fz_in v_fr_out v_ftheta_out v_fz_out v_fr_zplane v_ftheta_zplane v_fz_zplane mode scalar ave one file output/fix/file_timeav_wall_${rst_from}
label skip_ave_wall



# run pour and delete and add inner wall
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour2_innerwall"
run 10
region       	delete_in_small cylinder z 0. 0. ${ri_delete} 0 ${zhi_box} units box
delete_atoms 	region delete_in_small
if "${ifrotate} == yes" then &
  "fix	inwall		all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri} shear x ${in_velocity}" &
else &
  "fix	inwall		all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri}"
label	end_pour2_innerwall



# run
run ${runstep}

#start to move inwall
#define inner wall speed again
#variable        Sa equal 2e-6
#variable     omega_in equal $(sqrt(v_Sa*v_g*(v_ro-v_ri)^3/(v_dp)^2/v_ri^2))
#variable     in_velocity equal $(v_omega_in*v_ri)
#fix           inwall all wall/gran hooke/history ${kn} ${kt} ${gamma_n} ${gamma_t} 0.5 1 zcylinder ${ri} shear x ${in_velocity}
#run             5000 upto

#file, vtk
#dump            dmpatom all atom/vtk ${freq_dump_other} vtk/atom_*.vtk
#dump            dmpstl1 all mesh/stl ${freq_dump_other} stl/in*.stl cad1
#dump            dmpstl2 all mesh/stl ${freq_dump_other} stl/out*.stl cad2

#file, movie, have not work
#dump   m0 all movie ${freq_dump_other} output/dumpmovie/movie_${rst_from}.m4v type type size 640 480

#chunk method
#compute         chunk all chunk/atom bin/3d x lower 0.02 y lower 0.02 z lower 0.02 units reduced
#variable        xbin atom "floor( (x+v_ro)/ (2*v_ro)* v_N_bin_x )"
#variable        ybin atom floor((y+v_ro)/(2*v_ro)*v_N_bin_y)
#variable        zbin atom floor(z/v_zhi_chunk*v_N_bin_z)
#variable        mychunk2 atom 1+v_N_bin_z*(v_N_bin_y*v_xbin+v_ybin)+v_zbin
#compute         chunk2 all chunk/atom v_mychunk2 limit $(v_N_bin_x*v_N_bin_y*v_N_bin_z) exact 
#variable        thetabin atom floor((v_theta+PI)/(2*PI)*v_N_bin_theta)
#variable        chunk_id_rtz atom 1+v_N_bin_z*(v_N_bin_theta*v_rbin+v_thetabin)+v_zbin
#compute         chunkrtz all chunk/atom v_chunk_id_rtz limit ${N_total_bin} exact

