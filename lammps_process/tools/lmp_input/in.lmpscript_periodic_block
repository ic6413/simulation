# v20: add pair none for removing history
#      change fix id of wall/gran to contact eleminate history
# v19: add ifallcustom in one file or separate
# v18: add ifairviscous to determine air viscous
# v17: add option for print only max atom or trackid atom to a file
# v16: put all irrelevent command to other file
# v15: use immediate variable as much as possible. i.e. use immediate variable $() if the variable only define before run
# v14: fix pour
# v13: add maxKEt in thermo file. 
#      restart file path changed
# v12: create atom method added. can choose create manually but not to use lattice
# v11: delete "then" in elif, put mp before kn
# v10: separate compute pair group for all and trace
# v9:  move timestep command to after unit defined
# v8:  compute pair group change from only tracegroup to all
# v7:  add runstep
# v6:  if append-->yes. simulation box extend, no delete when using createbox, 
#      correct unit of freeze region to box. set no output if freq_* =0
# v5:  rounding number
# v4:  store force before fix (after pair). so get pair force
# only for block
variable    ifzbottomshear      index no
# only for create_atom_method latt
variable    ifsetinitialvelocity      index no
variable    ifinitialvelocity_same_as_in_velocity      index no
# initialization:
# timer
#timer loop # loop off full sync
# set step
variable rst_from index 0
variable ifset_velocity_after_rst index no
variable ifset_angular_velocity_after_rst index no
variable runstep index 1e7

variable runstep_loop index 1000000
if "${runstep_loop} == 0" then &
"variable n_loop equal 0" &
else &
"variable n_loop equal floor(v_runstep/v_runstep_loop)"

variable KEtr_to_jumpout equal 1e-25


# cd to output
shell	mkdir	output
# create output folders
shell	mkdir output/rst output/trace output/image/ output/image/all output/image/trace 
shell	mkdir output/momentum_mass_field output/vtk output/stl output/movie output/setting
shell	mkdir output/stress
shell	mkdir output/pair_trace output/single_trace output/pair_all output/single_all
shell	mkdir output/wall
shell	mkdir output/test
# print start step
print "startstep ${rst_from}" screen no append output/setting/attribute.lammps
# step start from. weather rotate start.
variable  contact_change index no
variable  contact_model index hooke_his #hooke hooke_his hertz hertz_his
if "${contact_model} == hooke_his" then &
  "variable  contact_model_string string gran/hooke/history" &
elif "${contact_model} == hooke" &
 "variable  contact_model_string string gran/hooke" &
elif "${contact_model} == hertz_his" &
 "variable  contact_model_string string gran/hertz/history" &
else &
 "quit 1"

if "${contact_model} == hooke_his" then &
  "variable  contact_model_wall_string string hooke/history" &
elif "${contact_model} == hooke" &
 "variable  contact_model_wall_string string hooke" &
elif "${contact_model} == hertz_his" &
 "variable  contact_model_wall_string string hertz/history" &
else &
 "quit 1"

# task number from slurm
variable    n_mpi_tasks     getenv OMPI_COMM_WORLD_SIZE
# processor cut in x dimension
if "$(v_n_mpi_tasks%2)==0" then &
"variable	n_processor_x		index 2" &
else &
"variable	n_processor_x		index 1"
# timestep
variable	ts_scale		index 1
variable  ts          equal $(v_ts_scale*4e-7)
print "timestep ${ts}" screen no append output/setting/attribute.lammps
# ztop
variable  ifztop   index yes 
# ybottom gran or flat
variable    if_inwall_wall_gran index no
variable    wall_gran_type       index 2
if "${if_inwall_wall_gran} == no" then &
  "variable storeforcegroup string all" &
else &
  "variable storeforcegroup string not_near_ybottom_wall"
# history
variable  eliminate_history   index no 
variable	ifrotate		index no
variable	trace_id1		index 0  # 0 means no trace
variable	trace_id2		index 0  # 0 means no trace
variable	trace_id3		index 0  # 0 means no trace
variable	iftrace_maxKEt		index no
variable	iftrace_maxKEr		index no
variable	iftrace_maxKEtr		index no
shell	mkdir output/trace/
if "${trace_id1} != 0" then &
"shell	mkdir output/trace/${trace_id1}"
if "${trace_id2} != 0" then &
"shell	mkdir output/trace/${trace_id2}"
if "${trace_id3} != 0" then &
"shell	mkdir output/trace/${trace_id3}"
if "${iftrace_maxKEt} == yes" then &
"shell	mkdir output/trace/maxKEt"
if "${iftrace_maxKEr} == yes" then &
"shell	mkdir output/trace/maxKEr"
if "${iftrace_maxKEtr} == yes" then &
"shell	mkdir output/trace/maxKEtr"

variable	ifappend		string no
variable	iffreeze		string no
# create atom method
# no means no create , latt means lattice, test_collide_1wall1atom means test collide of 1 wall and 1 atom
# test_collide_twoatoms means test collide of two atoms
variable	create_atom_method	index latt	
variable	ifpour			string no
variable  pourstep    equal 100
variable  pour_number equal 240000
variable  ifdeposit   string no
variable  deposit_number equal 120000

# chunk method x xy xyz r rz rzt NONE
if "${boundary_geometry} == block" then &
  "variable	chunk_method		string yz" &
elif "${boundary_geometry} == cylinder" &
  "variable	chunk_method		string rz" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
print "chunk_method ${chunk_method}" screen no append output/setting/attribute.lammps
# ifsetvelocity
variable	ifsetvelocity		string no
# reset dt
variable	ifresetdt		index no
# recount dof
if		"(${ifpour} == yes) || (${ifdeposit} == yes)" then &
  "variable	recount_dof		string yes" &
else &
  "variable	recount_dof		string no"
# frequency output
# freq restart
variable	freq_restart_big	index 0
variable	freq_restart_small	index 0
# freq image
variable	freq_dump_trace_image	index 0
variable	freq_dump_all_image	index 0
# freq dump
variable	freq_dump_single_trace	index 0
variable	freq_dump_single_all	index 0
variable  n_maxfile_single_all  index -1
variable	freq_dump_pair_trace	index 0
variable	freq_dump_pair_all	index 0
variable	freq_dump_all_vtk		index 0
variable	freq_dump_all_stl		index 0
variable	freq_dump_all_movie		index 0
# freq thermo
variable	freq_thermo		index 0 #stagger(1e3,2e2)       #
variable  thermo_lost_error_or_warn index error
# freq print trace
variable	freq_print_trace	index 0
# freq fix vector
variable	freq_fixvector		index 0
variable	every_fixvector		index 0
# freq print velocity field
variable	freq_ave_chunk_momentum_mass_field		index 0  #Nevery=2, Nrepeat=6, and Nfreq=100, then 90,92,94,96,98,100 count for average
variable	repeat_ave_chunk_momentum_mass_field	index 0
variable	every_ave_chunk_momentum_mass_field		index 0
print "freq_ave_chunk_momentum_mass_field ${freq_ave_chunk_momentum_mass_field}" screen no append output/setting/attribute.lammps
# freq print wall
variable	freq_ave_wall		index 0  #Nevery=2, Nrepeat=6, and Nfreq=100, then 90,92,94,96,98,100 count for average
variable	repeat_ave_wall		index 0
variable	every_ave_wall		index 0
# freq rebalance
variable  	freq_balance      	index 0
# freq check_condition_exit
variable  	freq_check_condition_exit      	index -1
variable    ke_per_atom_check index 1.0e-17
# number of type
variable	n_type			index 3 #1 or 3 or  0 means no create
print "n_type ${n_type}" screen no append output/setting/attribute.lammps
# type ratio if n_type is 3
variable	ratio_type1			equal 0.3
variable	ratio_type2			equal 0.4
variable	ratio_type3			equal 0.3

# if air viscous
variable	ifairviscous		index yes 
variable  gamma_air       index 100

# gravitational acceleration
variable	g			equal 9.8
print "gravitational_acceleration ${g}" screen no append output/setting/attribute.lammps


# particle diameter
variable	dp 			index 0.00083		#particle diameter
print "diameter ${dp}" screen no append output/setting/attribute.lammps
# define nbd radius
variable 	cutoff_dumpnb equal (1.11*v_dp)
# calculate radius
variable	rp		equal $(v_dp/2)		#particle radius
# particle density
variable	den 			index 2500
print "density ${den}" screen no append output/setting/attribute.lammps
# calculate mass
variable	mp 		equal $(4/3*PI*v_rp^3*v_den)
# radius of big and small atom
variable  dp_big_dp_unit		equal 1.1
variable	dp_small_dp_unit 	equal 0.9
variable  rp_big_dp_unit		equal $(v_dp_big_dp_unit/2)
variable	rp_small_dp_unit 	equal $(v_dp_small_dp_unit/2)

# skin
variable	skin_dp_unit		equal 0.5

## bulk parameter
# width and height of walls

variable	x_period_dp_unit		index 36	#inner radius
variable	ri_wall_dp_unit		index 36	#inner radius
variable	width_wall_dp_unit		index 17	#width
variable  zlo_wall_dp_unit index 0
# height create particles
variable	z_length_create_dp_unit		index 31

## calculate wall box create
# calculate ylo wall
variable	ylo_wall_dp_unit		equal 0
# calculate yhi wall
variable	yhi_wall_dp_unit		equal $(v_width_wall_dp_unit+v_ylo_wall_dp_unit)
# calculate ro wall
variable	ro_wall_dp_unit		equal $(v_ri_wall_dp_unit+v_width_wall_dp_unit)
# zlo zhi create particles
variable	zlo_create_dp_unit	equal $(v_zlo_wall_dp_unit+v_rp_big_dp_unit)
variable  zhi_create_dp_unit equal $(v_zlo_create_dp_unit+v_z_length_create_dp_unit)
# ylo yhi create particles
variable	yhi_create_dp_unit		equal $(v_yhi_wall_dp_unit-v_rp_big_dp_unit)
variable	ylo_create_dp_unit		equal $(v_ylo_wall_dp_unit+v_rp_big_dp_unit)
# ri ro create particles
variable	ro_create_dp_unit		equal $(v_ro_wall_dp_unit-v_rp_big_dp_unit)
variable	ri_create_dp_unit		equal $(v_ri_wall_dp_unit+v_rp_big_dp_unit)
# calculate zhi_wall
variable  zhi_wall_dp_unit equal $(v_zhi_create_dp_unit+4)
# simulation box
variable  zlo_box_dp_unit   equal $(v_zlo_wall_dp_unit-0.1)
variable	zhi_box_dp_unit		equal $(v_zhi_wall_dp_unit+0.1)
variable	ylo_box_dp_unit		equal $(v_ylo_wall_dp_unit-0.1)
variable	yhi_box_dp_unit		equal $(v_yhi_wall_dp_unit+0.1)
variable	ro_box_dp_unit		equal $(v_ro_wall_dp_unit+0.1)

# simulation box xlo xhi
variable	xlo_box_dp_unit		equal 0
variable	xhi_box_dp_unit		equal $(v_x_period_dp_unit+v_xlo_box_dp_unit)
# xlo xhi create particles
variable	xhi_create_dp_unit		equal $(v_xhi_box_dp_unit-v_rp_big_dp_unit)
variable	xlo_create_dp_unit		equal $(v_xlo_box_dp_unit+v_rp_big_dp_unit)

# chunk
variable	zhi_chunk_dp_unit	equal $(v_zhi_wall_dp_unit)
variable	zlo_chunk_dp_unit	equal $(v_zlo_wall_dp_unit)
variable	yhi_chunk_dp_unit	equal $(v_yhi_wall_dp_unit)
variable	ylo_chunk_dp_unit	equal $(v_ylo_wall_dp_unit)
variable	rhi_chunk_dp_unit	equal $(v_ro_wall_dp_unit)
variable	rlo_chunk_dp_unit	equal $(v_ri_wall_dp_unit)
# pour zlo zhi
variable	zlo_pour_dp_unit	equal $(v_zhi_box_dp_unit-2+0.999999999)
variable	zhi_pour_dp_unit	equal $(v_zhi_box_dp_unit-1)

# freeze region size
variable	zhi_freeze_dp_unit	equal 29
variable	y_lo_freeze_dp_unit	equal $(-v_rp_big_dp_unit)
variable	y_hi_freeze_dp_unit	equal $(v_width_wall_dp_unit+v_rp_big_dp_unit)
variable	ri_freeze_dp_unit	equal $(v_ri_wall_dp_unit-v_rp_big_dp_unit)
variable	ro_freeze_dp_unit	equal $(v_ro_wall_dp_unit+v_rp_big_dp_unit)

# contact model variable
variable	kn_scale	index 1000000
variable	kn		index $(v_kn_scale*v_mp*v_g/v_dp)
variable	kt		index $(2/7*v_kn)
variable	gamma_n_scale	index 317
variable	gamma_n		index $(v_gamma_n_scale*sqrt(v_g/v_dp))
variable	gamma_t 	index $(v_gamma_n/2)
variable	xmu		index 0.5
print "kn ${kn}" screen no append output/setting/attribute.lammps
print "kt ${kt}" screen no append output/setting/attribute.lammps
print "gamma_n ${gamma_n}" screen no append output/setting/attribute.lammps
print "gamma_t ${gamma_t}" screen no append output/setting/attribute.lammps
print "friction_coefficient ${xmu}" screen no append output/setting/attribute.lammps
variable	ifdamp_tangent	equal 1
# number of chunk
variable	bin_z_dp_unit_approximate 	equal 3
variable	bin_y_dp_unit_approximate 	equal 1
variable	bin_r_dp_unit_approximate 	equal 1
variable	bin_x_dp_unit_approximate 	equal 1

variable	N_bin_z 	equal $(round((v_zhi_chunk_dp_unit-v_zlo_chunk_dp_unit)/v_bin_z_dp_unit_approximate))
variable	N_bin_y 	equal $(round((v_yhi_chunk_dp_unit-v_ylo_chunk_dp_unit)/v_bin_y_dp_unit_approximate)) 
variable	N_bin_x	  equal $(round(v_x_period_dp_unit/v_bin_x_dp_unit_approximate))
variable	N_bin_r 	equal $(round((v_rhi_chunk_dp_unit-v_rlo_chunk_dp_unit)/v_bin_r_dp_unit_approximate)) 
variable	N_bin_theta	equal $(round(1/v_ri_wall_dp_unit))

print "N_bin_x ${N_bin_x}" screen no append output/setting/attribute.lammps
print "N_bin_y ${N_bin_y}" screen no append output/setting/attribute.lammps
print "N_bin_z ${N_bin_z}" screen no append output/setting/attribute.lammps
print "N_bin_r ${N_bin_r}" screen no append output/setting/attribute.lammps
print "N_bin_theta ${N_bin_theta}" screen no append output/setting/attribute.lammps
# salvage number
variable	Sa 		index 0.00000002

# calculate container size
variable  xlo_box     equal $(v_xlo_box_dp_unit*v_dp)
variable  xhi_box     equal $(v_xhi_box_dp_unit*v_dp)
variable	yhi_box		  equal $(v_yhi_box_dp_unit*v_dp)
variable	ylo_box 		equal $(v_ylo_box_dp_unit*v_dp)
variable	zhi_box		  equal $(v_zhi_box_dp_unit*v_dp)
variable	zlo_box 		equal $(v_zlo_box_dp_unit*v_dp)
variable  zlo_wall    equal $(v_zlo_wall_dp_unit*v_dp)
variable  zhi_wall    equal $(v_zhi_wall_dp_unit*v_dp)
variable  ylo_wall    equal $(v_ylo_wall_dp_unit*v_dp)
variable  yhi_wall    equal $(v_yhi_wall_dp_unit*v_dp)
variable	ro_wall		equal $(v_ro_wall_dp_unit*v_dp)
variable	ri_wall 		equal $(v_ri_wall_dp_unit*v_dp)
print "yhi_box ${yhi_box}" screen no append output/setting/attribute.lammps
print "ylo_box ${ylo_box}" screen no append output/setting/attribute.lammps
print "ro_wall ${ro_wall}" screen no append output/setting/attribute.lammps
print "ri_wall ${ri_wall}" screen no append output/setting/attribute.lammps
print "zlo_wall ${zlo_wall}" screen no append output/setting/attribute.lammps
print "zhi_wall ${zhi_wall}" screen no append output/setting/attribute.lammps
print "ylo_wall ${ylo_wall}" screen no append output/setting/attribute.lammps
print "yhi_wall ${yhi_wall}" screen no append output/setting/attribute.lammps
# calculate chunk
variable	zhi_chunk	equal $(v_zhi_chunk_dp_unit*v_dp)
variable	zlo_chunk	equal $(v_zlo_chunk_dp_unit*v_dp)
variable	yhi_chunk	equal $(v_yhi_chunk_dp_unit*v_dp)
variable	ylo_chunk	equal $(v_ylo_chunk_dp_unit*v_dp)
variable	rhi_chunk	equal $(v_rhi_chunk_dp_unit*v_dp)
variable	rlo_chunk	equal $(v_rlo_chunk_dp_unit*v_dp)
# calculate simulation box size
variable width_wall equal $(v_width_wall_dp_unit*v_dp)
variable ro_box equal $(v_ro_box_dp_unit*v_dp)
variable zhi_box 	equal $(v_zhi_box_dp_unit*v_dp)
variable zlo_box 	equal $(v_zlo_box_dp_unit*v_dp)
# calculate diameter of big and small
variable	dp_big		equal $(v_dp_big_dp_unit*v_dp)
variable	dp_small	equal $(v_dp_small_dp_unit*v_dp)
print "dp_big ${dp_big}" screen no append output/setting/attribute.lammps
print "dp_small ${dp_small}" screen no append output/setting/attribute.lammps

# calculate skin
variable	skin		equal $(v_skin_dp_unit*v_dp)

# calculate size of region to create atoms
variable	xlo_create	equal $(v_xlo_create_dp_unit*v_dp)
variable	xhi_create	equal $(v_xhi_create_dp_unit*v_dp)
variable	ylo_create	equal $(v_ylo_create_dp_unit*v_dp)
variable	yhi_create	equal $(v_yhi_create_dp_unit*v_dp)
variable	ri_create	equal $(v_ri_create_dp_unit*v_dp)
variable	ro_create	equal $(v_ro_create_dp_unit*v_dp)
variable	zlo_create	equal $(v_zlo_create_dp_unit*v_dp)
variable	zhi_create	equal $(v_zhi_create_dp_unit*v_dp)

# calculate pour zlo zhi
variable	zlo_pour	equal $(v_zlo_pour_dp_unit*v_dp)
variable	zhi_pour	equal $(v_zhi_pour_dp_unit*v_dp)

# calculate number of bin
variable	N_total_yz 	equal v_N_bin_y*v_N_bin_z
variable	N_total_rz 	equal v_N_bin_r*v_N_bin_z

# calculate inner wall speed
variable	omega_in 	equal $(sqrt(v_Sa*v_g*(v_ro_wall-v_ri_wall)^3/(v_dp)^2/v_ri_wall^2))
if "${boundary_geometry} == block" then &
  "variable	in_velocity 	equal $(sqrt(v_Sa*v_g*(v_width_wall)^3/(v_dp)^2))" &
elif "${boundary_geometry} == cylinder" &
  "variable	in_velocity 	equal $(v_omega_in*v_ri_wall)" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
variable	in_velocity_negative 	equal $(-v_in_velocity)
# calculate freeze region size
variable	zhi_freeze		equal $(v_zhi_freeze_dp_unit*v_dp)
variable	y_lo_freeze		equal $(v_y_lo_freeze_dp_unit*v_dp)
variable        y_hi_freeze		equal $(v_y_hi_freeze_dp_unit*v_dp)
variable	ri_freeze		equal $(v_ri_freeze_dp_unit*v_dp)
variable        ro_freeze		equal $(v_ro_freeze_dp_unit*v_dp)
# lattice primitive vectors length
variable	edge_lattice		equal $(2/(sqrt(3))*v_dp_big)
variable	z_fraction_of_lattice	equal $(sqrt(3)/4)
variable  create_center_y equal $((v_yhi_create+v_ylo_create)/2)
variable  create_center_x equal $((v_xhi_create+v_xlo_create)/2)
variable	y_fraction_of_lattice	equal $(v_create_center_y/v_edge_lattice-floor(v_create_center_y/v_edge_lattice))
variable	x_fraction_of_lattice	equal $(v_create_center_x/v_edge_lattice-floor(v_create_center_x/v_edge_lattice))
# variable for lattice ybottomwall
variable	edge_lattice_ybottom_wall		equal $(v_dp)
variable	z_fraction_of_lattice_ybottom_wall	equal $(v_zlo_wall/v_edge_lattice_ybottom_wall-floor(v_zlo_wall/v_edge_lattice_ybottom_wall))
variable	y_fraction_of_lattice_ybottom_wall	equal $(v_ylo_wall/v_edge_lattice_ybottom_wall-floor(v_ylo_wall/v_edge_lattice_ybottom_wall))
variable	x_fraction_of_lattice_ybottom_wall	equal $(v_xlo_box/v_edge_lattice_ybottom_wall-floor(v_xlo_box/v_edge_lattice_ybottom_wall))
# define cylinder coordinate position velocity
variable	d_z_axis	atom sqrt(x*x+y*y)
variable	theta 		atom atan2(y,x)
variable	vr 		atom (vx*x+vy*y)/sqrt(x*x+y*y)
variable	vt 		atom (vx*(-y)+vy*x)/sqrt(x*x+y*y)
# momentum
variable  mv3     atom mass*vz
variable	mv1 		atom mass*vx
variable	mv2 		atom mass*vy
variable	mv2 		atom mass*v_vr
variable	mv1 		atom mass*v_vt
variable	Ek2 		atom 0.5*mass*vy*vy
variable	Ek1 		atom 0.5*mass*vx*vx
variable	Ek3 		atom 0.5*mass*vz*vz
variable	Ek2 		atom 0.5*mass*v_vr*v_vr
variable	Ek1 		atom 0.5*mass*v_vt*v_vt
variable	my 		atom mass*y
variable	mr 		atom mass*v_vr
variable	mz 		atom mass*z
variable	check_vrvtvxvy 	atom v_vt*v_vt+v_vr*v_vr-vx*vx-vy*vy
# calculate chunk id
variable	ybin		atom "floor((y-v_ylo_chunk)/ (v_yhi_chunk-v_ylo_chunk)* v_N_bin_y )"
variable	rbin		atom "floor( (v_d_z_axis-v_rlo_chunk)/ (v_rhi_chunk-v_rlo_chunk)* v_N_bin_r )"
variable	zbin		atom "floor((z-v_zlo_chunk)/ (v_zhi_chunk-v_zlo_chunk)* v_N_bin_z)"
variable        chunk_id_r_z	atom 1+v_N_bin_r*v_zbin+v_rbin

# processors
if "${boundary_geometry} == block" then &
  "processors  * * *" &
elif "${boundary_geometry} == cylinder" &
  "processors  ${n_processor_x} * *" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"


# jump to restart section
if	"${rst_from} > 0" 	then "jump SELF end_restart_skip1"
#newton
# default is on so only need when off
#newton       on
# setting, no restart
atom_style	sphere
atom_modify	map array
if "${boundary_geometry} == block" then &
  "boundary	p f f" &
elif "${boundary_geometry} == cylinder" &
  "boundary	f f f" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
units		si
#timestep
timestep     ${ts}
# communication, no restart
comm_style	brick
comm_modify	vel yes

# reg to define box, no restart
if "${boundary_geometry} == block" then &
  "region		simulation_box block ${xlo_box} ${xhi_box} ${ylo_box} ${yhi_box} ${zlo_box} ${zhi_box} units box" &
elif "${boundary_geometry} == cylinder" &
  "region		simulation_box cylinder z 0. 0. ${ro_box} ${zlo_box} ${zhi_box} units box" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"

# create box
create_box	${n_type} simulation_box
# contact force style, no restart

pair_style	${contact_model_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent}

pair_coeff	* *


# insert region
# block
region	in_outbdy_insert 	block ${xlo_create} ${xhi_create} ${ylo_create} ${yhi_create} ${zlo_create} ${zhi_create} units box
# cylinder
region	out_inbdy_insert_cy 	cylinder z 0. 0. ${ri_create} ${zlo_box} ${zhi_box} units box side out
region	in_outbdy_insert_cy 	cylinder z 0. 0. ${ro_create} ${zlo_create} ${zhi_create} units box
region	region_ins_0_cy		intersect 2 out_inbdy_insert_cy in_outbdy_insert_cy units box
# insert more region
# block
region	in_outbdy_append 	block 0 ${xhi_box} ${y_lo_freeze} ${y_hi_freeze} 0 ${zhi_freeze} units box
# cylinder
region	out_inbdy_append_cy 	cylinder z 0. 0. ${ri_freeze} 0 ${zhi_freeze} units box side out
region	in_outbdy_append_cy 	cylinder z 0. 0. ${ro_freeze} 0 ${zhi_freeze} units box
region	region_append_cy		intersect 2 out_inbdy_append_cy in_outbdy_append_cy units box
# extend insert region to freeze region
# block
if "${ifappend} == no" then &
  "region	region_ins 	block ${xlo_create} ${xhi_create} ${ylo_create} ${yhi_create} ${zlo_create} ${zhi_create} units box" &
else &
  "region	region_ins	union 2 in_outbdy_insert in_outbdy_append units box"
# cylinder
if "${ifappend} == no" then &
  "region	region_ins_cy	intersect 2 out_inbdy_insert_cy in_outbdy_insert_cy units box" &
else &
  "region	region_ins_cy	union 2 region_ins_0_cy region_append_cy units box"
if "${create_atom_method} == no" then &
  "jump SELF end_create"

# create particle at lattice, no restart
# with scale = 1, a1 = 1 0 0, a2 = 0 1 0, and a3 = 0 0 1, no restart
if "${boundary_geometry} == block" then &
  "lattice       bcc ${edge_lattice} origin ${x_fraction_of_lattice} ${y_fraction_of_lattice} ${z_fraction_of_lattice}" &
elif "${boundary_geometry} == cylinder" &
  "lattice       bcc ${edge_lattice} origin 0 0 ${z_fraction_of_lattice}" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
if "${n_type} == 3" then &
  "jump SELF begin3type" &
elif "${n_type} == 1" &
  "jump SELF begin1type" &
else &
  "print 'n_type not 3 or 1'"

# 3type begin
label		begin3type

# jump create atom by lattice
if "${create_atom_method} != latt" then &
  "jump SELF end_lattice1"
if "${boundary_geometry} == block" then &
  "create_atoms	2 region region_ins units lattice" &
elif "${boundary_geometry} == cylinder" &
  "create_atoms	2 region region_ins_cy units lattice" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
set		atom * type/fraction 1 0.6 12393
set		type 1 type/fraction 3 0.5 12235
# set diameter before density, otherwise mass won't fit, no restart
set		type 1 diameter ${dp_small}
set		type 2 diameter ${dp}
set		type 3 diameter ${dp_big}
set		atom * density 	${den}


if "${ifsetinitialvelocity} == yes && ${boundary_geometry} == cylinder" then &
  "print 'cylinder geometry have not write code initialvelocity for particles'" &
  "quit 1"

if "${ifsetinitialvelocity} == yes" then &
  "jump SELF ifsetinitialvelocity_begin1" &
else &
  "jump SELF ifsetinitialvelocity_end1"

label ifsetinitialvelocity_begin1

if "${ifinitialvelocity_same_as_in_velocity} == yes" then &
  "jump SELF ifinitialvelocity_same_as_in_velocity_begin1" &
else &
  "jump SELF ifinitialvelocity_same_as_in_velocity_end1"

label ifinitialvelocity_same_as_in_velocity_begin1
set atom * vx ${in_velocity}
jump SELF ifsetinitialvelocity_end1
label ifinitialvelocity_same_as_in_velocity_end1

label ifsetinitialvelocity_end1


#displace
#displace_atoms all random 1e-11 1e-11 0 987 units box

# 3type end
jump		SELF end_create
label   end_lattice1

# 1type begin
label		begin1type
# jump create atom by lattice
if "${create_atom_method} != latt" then &
  "jump SELF end_lattice2"
if "${boundary_geometry} == block" then &
  "create_atoms	1 region region_ins units lattice" &
elif "${boundary_geometry} == cylinder" &
  "create_atoms	1 region region_ins_cy units lattice" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# set diameter before density, otherwise mass won't fit, no restart
set		atom * diameter ${dp}
set		atom * density 	${den}
jump		SELF end_create
label   end_lattice2

if "${create_atom_method} != test_collide_1wall1atom" then &
  "jump SELF end_test_collide_1wall1atom"
# create_atoms	1 region region_ins units lattice 
# test create 1 single atoms let inner wall collision
if "${boundary_geometry} == block" then &
  "create_atoms 1 single $(0.01*v_dp) $((v_ri_wall_dp_unit+0.6)*v_dp) $(0.50001*v_dp) units box" &
elif "${boundary_geometry} == cylinder" &
  "create_atoms 1 single $(0*v_dp) $((v_ri_wall_dp_unit+0.6)*v_dp) $(0.50001*v_dp) units box" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"

# set diameter before density, otherwise mass won't fit, no restart
set		atom * diameter ${dp}
set		atom * density 	${den}
# test set velocity
set atom 1 vy $(-1.0*v_dp)
#set atom 1 vz $(-1.0*v_dp)
#set atom 2 vy $(1.0*v_dp)
# test non parallel rotate (Say contact point is c, the plane composited by vc and ac will changed over the contact time.)
set atom 1 omega 1.0 0 0
jump		SELF end_create
label   end_test_collide_1wall1atom

if "${create_atom_method} != test_collide_twoatoms" then &
  "jump SELF end_test_collide_twoatoms"

# create_atoms	1 region region_ins units lattice
# test create 3 single atoms let 1 2 collision

jump		SELF end_create
label   begin_3_collide
if "${boundary_geometry} == block" then &
  "jump		SELF begin_3_collide_block" &
elif "${boundary_geometry} == cylinder" &
  "jump   SELF begin_3_collide_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
label   begin_3_collide_block
create_atoms 1 single $(0.434*v_dp) $((v_ylo_create_dp_unit+3.5)*v_dp) $(1*v_dp) units box
create_atoms 1 single $(-0.434*v_dp) $((v_ylo_create_dp_unit+3)*v_dp) $(1*v_dp) units box
create_atoms 1 single $(0.5*v_dp) $(-(v_ylo_create_dp_unit+3)*v_dp) $(1*v_dp) units box
# set diameter before density, otherwise mass won't fit, no restart
set		atom * diameter ${dp}
set		atom * density 	${den}
# test set velocity
set atom 1 vx $(-1.0*v_dp)
set atom 2 vx $(1.0*v_dp)

# test non parallel rotate (Say contact point is c, the plane composited by vc and ac will changed over the contact time.)
set atom 1 omega 0 1.0 0
label   end_3_collide_block
jump		SELF end_3_collide

label   begin_3_collide_cy
create_atoms 1 single $((v_ri_wall_dp_unit+3.5)*v_dp) $(0.434*v_dp) $(1*v_dp) units box
create_atoms 1 single $((v_ri_wall_dp_unit+3)*v_dp) $(-0.434*v_dp) $(1*v_dp) units box
create_atoms 1 single $(-(v_ri_wall_dp_unit+3)*v_dp) $(0.5*v_dp) $(1*v_dp) units box
# set diameter before density, otherwise mass won't fit, no restart
set		atom * diameter ${dp}
set		atom * density 	${den}
# test set velocity
set atom 1 vy $(-1.0*v_dp)
set atom 2 vy $(1.0*v_dp)

# test non parallel rotate (Say contact point is c, the plane composited by vc and ac will changed over the contact time.)
set atom 1 omega 1.0 0 0
label   end_3_collide_cy
jump		SELF end_3_collide
label   end_3_collide

jump		SELF end_create
label   end_test_collide_twoatoms

# create end
label		end_create

# file, restart 0 step
write_restart	output/rst/restart.mpiio.*

# jump gravity ifpour and step from 0
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour5"
# gravity
fix	gravi 		${storeforcegroup} gravity $g vector 0.0 0.0 -1.0
# gravitational potential
fix_modify		gravi energy yes
label	end_pour5
# pour region, block, z-axis cylinder, side = in, no restart
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour"
label	begin_pour
if "${boundary_geometry} == block" then &
  "region	pour_region	block ${xlo_box} ${xhi_box} ${ylo_create} ${yhi_create} ${zlo} ${zhi_create} units box" &
elif "${boundary_geometry} == cylinder" &
  "region	pour_region	cylinder z 0. 0. ${ro_create} ${zlo_pour} ${zhi_pour} units box" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
fix	pour_fix	all pour ${pour_number} 1 300719 region pour_region diam poly 3 $(0.9*v_dp) $(v_ratio_type1) $(v_dp) $(v_ratio_type2) $(1.1*v_dp) $(v_ratio_type3) dens 2500 2500 vol 100000 1
label	end_pour

# deposit region, block, z-axis cylinder, side = in, no restart
if "${ifdeposit} == no || ${rst_from} != 0" then "jump SELF end_deposit"

label	begin_deposit
if "${boundary_geometry} == block" then &
  "region  deposit_region block ${xlo_box} ${xhi_box} ${ylo_create} ${yhi_create} ${zlo} ${zhi_create} units box" &
elif "${boundary_geometry} == cylinder" &
  "region  deposit_in_region_sideout_cy cylinder z 0. 0. ${ri_create} ${zlo_pour} ${zhi_pour} units box side out" &
  "region  deposit_out_region_cy	cylinder z 0. 0. ${ro_create} ${zlo_pour} ${zhi_pour} units box" &
  "region  deposit_region intersect 2 deposit_in_region_sideout_cy deposit_out_region_cy units box" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"

if "${n_type} == 3" then &
  "jump SELF begin3type_deposit" &
elif "${n_type} == 1" &
  "jump SELF begin1type_deposit" &
else &
  "print 'n_type not 3 or 1'"

# 1type deposit begin
label		begin1type_deposit

fix	deposit_type1_fix	all deposit ${v_deposit_number} 1 1 29494 region deposit_region near ${dp} units box
set		type * diameter ${dp}
set		atom * density 	${den}
jump SELF end_deposit

# 3type deposit begin
label		begin3type_deposit
# set diameter before density, otherwise mass won't fit, no restart

variable number_type1 equal $(v_ratio_type1*v_deposit_number)
variable number_type2 equal $(v_ratio_type2*v_deposit_number)
variable number_type3 equal $(v_ratio_type3*v_deposit_number)
fix	deposit_type1_fix	all deposit ${number_type1} 1 4 29494 region deposit_region near ${dp_big} units box
fix	deposit_type2_fix	all deposit ${number_type2} 2 3 12235 region deposit_region near ${dp_big} units box
fix	deposit_type3_fix	all deposit ${number_type3} 3 4 777 region deposit_region near ${dp_big} units box
set		type 1 diameter ${dp_small}
set		type 2 diameter ${dp}
set		type 3 diameter ${dp_big}
set		atom * density 	${den}
jump SELF end_deposit

label	end_deposit

# gran wall, create freezed atoms as ybottom_wall and delete original created atoms if overlap with ybottom_wall atoms
if "${if_inwall_wall_gran} == no" then &
  "jump SELF ybottom_wall_gran_end1"
label ybottom_wall_gran_begin1

region  region_delete_original  block INF INF INF $(v_ylo_wall+0.5*v_dp) INF INF units box
delete_atoms region region_delete_original

region	region_near_ybottom_wall_create	block INF INF INF $(v_ylo_wall+0.1*v_dp) $(v_zlo_wall) ${zhi_wall} units box
region	region_near_ybottom_wall_freeze	block INF INF INF $(v_ylo_wall+0.1*v_dp) INF INF units box
lattice       custom ${dp} origin ${x_fraction_of_lattice_ybottom_wall} ${y_fraction_of_lattice_ybottom_wall} ${z_fraction_of_lattice_ybottom_wall} &
a1 1.0 0.0 0.0 a2 0.0 1.0 0.0 a3 0.0 0.0 1.0 basis 0.0 0.0 0.5
if "${wall_gran_type} == 1" then "variable dp_wall_gran equal v_dp_small"
if "${wall_gran_type} == 2" then "variable dp_wall_gran equal v_dp"
if "${wall_gran_type} == 3" then "variable dp_wall_gran equal v_dp_big"
create_atoms	${wall_gran_type} region region_near_ybottom_wall_create units lattice

set		type ${wall_gran_type} diameter ${dp_wall_gran}
set		atom * density 	${den}

group group_small type 1
group group_middle type 2
group group_big type 3
group near_ybottom_wall_gran region region_near_ybottom_wall_freeze
group not_near_ybottom_wall subtract all near_ybottom_wall_gran
group not_near_ybottom_wall_small   intersect not_near_ybottom_wall group_small
group not_near_ybottom_wall_middle  intersect not_near_ybottom_wall group_middle
group not_near_ybottom_wall_big   intersect not_near_ybottom_wall group_big

delete_atoms overlap $((v_dp_wall_gran+v_dp_small)/2) not_near_ybottom_wall_small near_ybottom_wall_gran
delete_atoms overlap $((v_dp_wall_gran+v_dp)/2) not_near_ybottom_wall_middle near_ybottom_wall_gran
delete_atoms overlap $((v_dp_wall_gran+v_dp_big)/2) not_near_ybottom_wall_big near_ybottom_wall_gran

label ybottom_wall_gran_end1

# no need restart command end
label		end_restart_skip1

# need restart command begin
# jump if restart from nonzero step
# this command specify in jobscribe "variable	rst_from equal N" be used as suffix in output file name
if		"${rst_from} != 0" then &
  "read_restart restart.mpiio.${rst_from}"

# bin size and memory
neighbor	${skin} bin
neigh_modify	delay 0 #page 20

if		"${rst_from} != 0 && ${ifset_velocity_after_rst} == yes" then &
  "set group ${storeforcegroup} vx 0.0 vy 0.0 vz 0.0"

if		"${rst_from} != 0 && ${ifset_angular_velocity_after_rst} == yes" then &
  "set group ${storeforcegroup} omega 0.0 0.0 0.0"

if "${contact_change} == no || ${rst_from} == 0" &
 then "jump SELF contact_change_end1"

if "${contact_model} != hooke" &
 then "jump SELF hooke_end4"
pair_style none
pair_style	${contact_model_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent}
pair_coeff	* *

label hooke_end4

if "${contact_model} != hooke_his" &
 then "jump SELF hooke_his_end4"
if "${eliminate_history} == no || ${rst_from} == 0" then &
  "jump SELF reset_pair_history_end"
pair_style zero
pair_coeff	* *
run 1
pair_style	${contact_model_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent}
pair_coeff	* *
label   reset_pair_history_end
label hooke_his_end4

label contact_change_end1

fix	sum_pairforce	${storeforcegroup} store/force
if "${if_inwall_wall_gran} == no" then &
  "jump SELF ybottom_wall_gran_end4"
label ybottom_wall_gran_begin4
set		group near_ybottom_wall_gran 	vx ${in_velocity}
label ybottom_wall_gran_end4

# balance
#balance 	1.0 shift yz 100 1.02

# particle force (apply force from the one need to be output and small to large)
# store force fx fy fz

# wall force to particles
# inner wall begin
# define inner wall, if pour then define inner wall after pouring
if "${ifpour} == yes && ${rst_from} == 0" then "jump SELF end_pour6_innerwall"
fix	storeforce_inwall_before	${storeforcegroup} store/force
if "${if_inwall_wall_gran} != no" then &
  "jump SELF ybottom_wall_flat_end1"
# inner wall
label begin_inwall
if "${boundary_geometry} == block" then &
  "jump SELF begin_inwall_block" &
elif "${boundary_geometry} == cylinder" &
  "jump SELF begin_inwall_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# block
label begin_inwall_block
if "${ifrotate} == yes" then &
  "fix	y_bottom		all wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} yplane ${ylo_wall} NULL shear x ${in_velocity}" &
else &
  "fix	y_bottom		all wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} yplane ${ylo_wall} NULL"
label end_inwall_block
jump SELF end_inwall
# cylinder
label begin_inwall_cy
if "${ifrotate} == yes" then &
  "fix	inwall		all wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri_wall} shear x ${in_velocity_negative}" &
else &
  "fix	inwall		all wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri_wall}"
label end_inwall_cy
jump SELF end_inwall
label end_inwall
fix	storeforce_inwall_after	all store/force
label ybottom_wall_flat_end1
label	end_pour6_innerwall
# inner wall end
# outwall begin
fix	storeforce_outwall_before	${storeforcegroup} store/force
if "${boundary_geometry} == block" then &
  "fix	outwall 	${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} yplane NULL ${yhi_wall}" &
elif "${boundary_geometry} == cylinder" &
  "fix	outwall 	${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ro_wall}" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
fix	storeforce_outwall_after	${storeforcegroup} store/force
# outwall end
# z bottom begin
fix	storeforce_zbottom_before	${storeforcegroup} store/force
if "${ifzbottomshear} == yes" &
then "jump SELF z_bottom_shear_begin1" &
else &
"jump SELF z_bottom_not_shear_begin1"
# shear begin
label z_bottom_shear_begin1
fix	zplane_bottom 	${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zplane ${zlo_wall} NULL shear x ${in_velocity}
jump SELF z_bottom_end1
# not shear begin
label z_bottom_not_shear_begin1
fix	zplane_bottom 	${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zplane ${zlo_wall} NULL
fix	storeforce_zbottom_after	${storeforcegroup} store/force
label z_bottom_end1
# z bottom end
# z top begin
if "${ifztop} != yes" then "jump SELF ztop_end1"
fix	storeforce_ztop_before	${storeforcegroup} store/force
fix	zplane_top 	all wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zplane NULL ${zhi_wall}
fix	storeforce_ztop_after	${storeforcegroup} store/force
label ztop_end1
# z top end

# jump gravity ifpour and step from 0
if "${ifpour} == yes && ${rst_from} == 0" then "jump SELF end_pour4"
# gravity
fix	gravi 		${storeforcegroup} gravity $g vector 0.0 0.0 -1.0
# gravitational potential
fix_modify		gravi energy yes
label	end_pour4

if "${iffreeze} == no" then "jump SELF label_end_freeze"
# freeze region
region	region_freeze	block INF INF INF INF INF ${zhi_freeze} units box
# freeze atoms, but freeze_group not to be re-define when restart
if      "${rst_from} == 0"	then "group	freeze_group	region region_freeze"
if	"${ifsetvelocity} == yes"	then "velocity freeze_group set 0 0 0"
fix	freeze_fix	freeze_group freeze

label	label_end_freeze

# air viscous
print "ifairviscous ${ifairviscous}" screen no append output/setting/attribute.lammps
print "gamma_air ${gamma_air}" screen no append output/setting/attribute.lammps
if "${ifairviscous} == no" then &
  "jump SELF end_airviscous"
fix	storeforce_airviscous_before	${storeforcegroup} store/force
fix airviscous all viscous $(v_gamma_air*v_mp)
fix	storeforce_airviscous_after	${storeforcegroup} store/force
label   end_airviscous

# ensure temperture normalize correctly as particle number change. use when pour and temperature compute ke
if "${recount_dof} == yes" then &
  "compute_modify		thermo_temp dynamic/dof yes"

# nve integration update position velocity
if "${ifresetdt} == yes" then &
  "fix	reset		all dt/reset 1 NULL NULL $(sqrt(2*v_mp*v_g*v_zhi_box/v_kn)*sin(PI/50)) emax $(v_mp*v_g*v_zhi_box/25) units box"
fix	integr		all nve/sphere


# output
# output variable
variable	t equal time

# compute per-atom stress 9-element vector in the following order: xx, yy, zz, xy, xz, yz, yx, zx, zy.
compute stress ${storeforcegroup} stress/atom NULL ke pair

# compute chunk
if "${freq_ave_chunk_momentum_mass_field} == 0" then "jump SELF skip_ave_chunk"
if "${boundary_geometry} == block" then &
  "compute		chunk_2_3 ${storeforcegroup} chunk/atom bin/2d y $(v_ylo_chunk) $((v_yhi_chunk-v_ylo_chunk)/v_N_bin_y) z $(v_zlo_chunk) $((v_zhi_chunk-v_zlo_chunk)/v_N_bin_z) &
  limit ${N_total_yz} exact units box bound y $(v_ylo_chunk) $(v_yhi_chunk) bound z $(v_zlo_chunk) $(v_zhi_chunk) discard yes" &
elif "${boundary_geometry} == cylinder" &
  "compute		chunk_2_3 ${storeforcegroup} chunk/atom v_chunk_id_r_z limit ${N_total_rz} exact discard yes" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"



# file, output by fix ave/chunk
if "${freq_ave_chunk_momentum_mass_field} == 0" then "jump SELF skip_ave_chunk"
compute		m1 all property/atom mass
compute		omega all property/atom omegax omegay omegaz
variable  inwall_per_atom_1 atom f_storeforce_inwall_after[1] - f_storeforce_inwall_before[1]
variable  inwall_per_atom_2 atom f_storeforce_inwall_after[2] - f_storeforce_inwall_before[2]
variable  inwall_per_atom_3 atom f_storeforce_inwall_after[3] - f_storeforce_inwall_before[3]
variable  outwall_per_atom_1 atom f_storeforce_outwall_after[1] - f_storeforce_outwall_before[1]
variable  outwall_per_atom_2 atom f_storeforce_outwall_after[2] - f_storeforce_outwall_before[2]
variable  outwall_per_atom_3 atom f_storeforce_outwall_after[3] - f_storeforce_outwall_before[3]
variable  zbottom_per_atom_1 atom f_storeforce_zbottom_after[1] - f_storeforce_zbottom_before[1]
variable  zbottom_per_atom_2 atom f_storeforce_zbottom_after[2] - f_storeforce_zbottom_before[2]
variable  zbottom_per_atom_3 atom f_storeforce_zbottom_after[3] - f_storeforce_zbottom_before[3]

fix		avspatial ${storeforcegroup} ave/chunk ${every_ave_chunk_momentum_mass_field} ${repeat_ave_chunk_momentum_mass_field} ${freq_ave_chunk_momentum_mass_field} chunk_2_3 &
v_mv2 v_mv1 v_mv3 v_Ek1 v_Ek2 v_Ek3 c_m1 temp v_my v_mz c_omega[*] norm none file output/momentum_mass_field/fix.momentum_mass_field.all

fix		avspatialstress ${storeforcegroup} ave/chunk ${every_ave_chunk_momentum_mass_field} ${repeat_ave_chunk_momentum_mass_field} ${freq_ave_chunk_momentum_mass_field} chunk_2_3 &
c_stress[*] v_inwall_per_atom_1 v_inwall_per_atom_2 v_inwall_per_atom_3 outwall_per_atom_1 outwall_per_atom_2 outwall_per_atom_3 zbottom_per_atom_1 zbottom_per_atom_2 zbottom_per_atom_3 norm none file output/stress/fix.stress.all
label skip_ave_chunk

### wall force
## inwall force
if "${if_inwall_wall_gran} != no" then &
  "jump SELF ybottom_wall_flat_end3"
label ybottom_wall_flat_begin3
label begin_in_force
if "${boundary_geometry} == block" then &
  "jump SELF begin_in_force_block" &
elif "${boundary_geometry} == cylinder" &
  "jump SELF begin_in_force_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# block
label begin_in_force_block
if "${if_inwall_wall_gran} == no" then &
  "jump SELF begin_in_force_block_flat" &
else &
  "jump SELF begin_in_force_block_gran" &
# flat
label begin_in_force_block_flat
# compute total force on particles before inwall apply 
compute		sum_storeforce_inwall_before_xyz ${storeforcegroup} reduce sum f_storeforce_inwall_before[*]
# compute total force on particles after inwall apply 
compute		sum_storeforce_inwall_after_xyz all reduce sum f_storeforce_inwall_after[*]
# total force all atoms on inwall by substract
variable	force_inwall_1 equal c_sum_storeforce_inwall_after_xyz[1]-c_sum_storeforce_inwall_before_xyz[1]
variable	force_inwall_2 equal c_sum_storeforce_inwall_after_xyz[2]-c_sum_storeforce_inwall_before_xyz[2]
variable	force_inwall_3 equal c_sum_storeforce_inwall_after_xyz[3]-c_sum_storeforce_inwall_before_xyz[3]
label end_in_force_block_flat
jump SELF end_in_force_block
# gran
label begin_in_force_block_gran
# compute total force on particles after y_bottom apply 
compute		sum_storeforce_y_bottom_after_xyz ${storeforcegroup} reduce sum f_sum_pairforce[*]
# total force all atoms on y_bottom by substract
variable	force_inwall_1 equal c_sum_storeforce_y_bottom_after_xyz[1]
variable	force_inwall_2 equal c_sum_storeforce_y_bottom_after_xyz[2]
variable	force_inwall_3 equal c_sum_storeforce_y_bottom_after_xyz[3]
label end_in_force_block_gran
jump SELF end_in_force_block
label end_in_force_block
jump SELF end_in_force
# cylinder
label begin_in_force_cy
# compute total force on particles before inwall apply
variable	storeforce_inwall_before_2 atom (f_storeforce_inwall_before[1]*x+f_storeforce_inwall_before[2]*y)/sqrt(x*x+y*y)
variable	storeforce_inwall_before_1 atom (f_storeforce_inwall_before[1]*(-y)+f_storeforce_inwall_before[2]*x)/sqrt(x*x+y*y)
compute		sum_storeforce_inwall_before_2 all reduce sum v_storeforce_inwall_before_2
compute		sum_storeforce_inwall_before_1 all reduce sum v_storeforce_inwall_before_1
compute		sum_storeforce_inwall_before_3 all reduce sum f_storeforce_inwall_before[3]
# compute total force on particles after inwall apply 
variable	storeforce_inwall_after_2 atom (f_storeforce_inwall_after[1]*x+f_storeforce_inwall_after[2]*y)/sqrt(x*x+y*y)
variable	storeforce_inwall_after_1 atom (f_storeforce_inwall_after[1]*(-y)+f_storeforce_inwall_after[2]*x)/sqrt(x*x+y*y)
compute		sum_storeforce_inwall_after_2 all reduce sum v_storeforce_inwall_after_2
compute		sum_storeforce_inwall_after_1 all reduce sum v_storeforce_inwall_after_1
compute		sum_storeforce_inwall_after_3 all reduce sum f_storeforce_inwall_after[3]
# total force all atoms on inwall by substract 
variable	force_inwall_1 equal c_sum_storeforce_inwall_after_1-c_sum_storeforce_inwall_before_1
variable	force_inwall_2 equal c_sum_storeforce_inwall_after_2-c_sum_storeforce_inwall_before_2
variable	force_inwall_3 equal c_sum_storeforce_inwall_after_3-c_sum_storeforce_inwall_before_3
label end_in_force_cy
jump SELF end_in_force
label end_in_force
label ybottom_wall_flat_end3


## outwall force
label begin_out_force
if "${boundary_geometry} == block" then &
  "jump SELF begin_out_force_block" &
elif "${boundary_geometry} == cylinder" &
  "jump SELF begin_out_force_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# block
label begin_out_force_block
# compute total force on particles before outwall apply 
compute		sum_storeforce_outwall_before_xyz ${storeforcegroup} reduce sum f_storeforce_outwall_before[*]
# compute total force on particles after outwall apply 
compute		sum_storeforce_outwall_after_xyz ${storeforcegroup} reduce sum f_storeforce_outwall_after[*]
# total force all atoms on y_top by substract
variable	force_outwall_1 equal c_sum_storeforce_outwall_after_xyz[1]-c_sum_storeforce_outwall_before_xyz[1]
variable	force_outwall_2 equal c_sum_storeforce_outwall_after_xyz[2]-c_sum_storeforce_outwall_before_xyz[2]
variable	force_outwall_3 equal c_sum_storeforce_outwall_after_xyz[3]-c_sum_storeforce_outwall_before_xyz[3]
label end_out_force_block
jump SELF end_out_force
# cylinder
label begin_out_force_cy
# compute total force on particles before outwall apply 
variable	storeforce_outwall_before_r atom (f_storeforce_outwall_before[1]*x+f_storeforce_outwall_before[2]*y)/sqrt(x*x+y*y)
variable	storeforce_outwall_before_theta atom (f_storeforce_outwall_before[1]*(-y)+f_storeforce_outwall_before[2]*x)/sqrt(x*x+y*y)
compute		sum_storeforce_outwall_before_r all reduce sum v_storeforce_outwall_before_r
compute		sum_storeforce_outwall_before_theta all reduce sum v_storeforce_outwall_before_theta
compute		sum_storeforce_outwall_before_z all reduce sum f_storeforce_outwall_before[3]
# compute total force on particles after outwall apply 
variable	storeforce_outwall_after_r atom (f_storeforce_outwall_after[1]*x+f_storeforce_outwall_after[2]*y)/sqrt(x*x+y*y)
variable	storeforce_outwall_after_theta atom (f_storeforce_outwall_after[1]*(-y)+f_storeforce_outwall_after[2]*x)/sqrt(x*x+y*y)
compute		sum_storeforce_outwall_after_r all reduce sum v_storeforce_outwall_after_r
compute		sum_storeforce_outwall_after_theta all reduce sum v_storeforce_outwall_after_theta
compute		sum_storeforce_outwall_after_z all reduce sum f_storeforce_outwall_after[3]
# total force all atoms on outwall by substract 
variable	force_outwall_2 equal c_sum_storeforce_outwall_after_r-c_sum_storeforce_outwall_before_r
variable	force_outwall_1 equal c_sum_storeforce_outwall_after_theta-c_sum_storeforce_outwall_before_theta
variable	force_outwall_3 equal c_sum_storeforce_outwall_after_z-c_sum_storeforce_outwall_before_z
label end_out_force_cy
jump SELF end_out_force
label end_out_force
## zbottom force
label begin_bottom_force
if "${boundary_geometry} == block" then &
  "jump SELF begin_bottom_force_block" &
elif "${boundary_geometry} == cylinder" &
  "jump SELF begin_bottom_force_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# block
label begin_bottom_force_block
# compute total force on particles before zbottom apply 
compute		sum_storeforce_zbottom_before_xyz ${storeforcegroup} reduce sum f_storeforce_zbottom_before[*]
# compute total force on particles after zbottom apply 
compute		sum_storeforce_zbottom_after_xyz ${storeforcegroup} reduce sum f_storeforce_zbottom_after[*]
# total force all atoms on zbottom by substract
variable	force_zbottom_1 equal c_sum_storeforce_zbottom_after_xyz[1]-c_sum_storeforce_zbottom_before_xyz[1]
variable	force_zbottom_2 equal c_sum_storeforce_zbottom_after_xyz[2]-c_sum_storeforce_zbottom_before_xyz[2]
variable	force_zbottom_3 equal c_sum_storeforce_zbottom_after_xyz[3]-c_sum_storeforce_zbottom_before_xyz[3]
label end_bottom_force_block
jump SELF end_bottom_force
# cylinder
label begin_bottom_force_cy
# compute total force on particles before zbottom apply 
variable	storeforce_zbottom_before_r atom (f_storeforce_zbottom_before[1]*x+f_storeforce_zbottom_before[2]*y)/sqrt(x*x+y*y)
variable	storeforce_zbottom_before_theta atom (f_storeforce_zbottom_before[1]*(-y)+f_storeforce_zbottom_before[2]*x)/sqrt(x*x+y*y)
compute		sum_storeforce_zbottom_before_r all reduce sum v_storeforce_zbottom_before_r
compute		sum_storeforce_zbottom_before_theta all reduce sum v_storeforce_zbottom_before_theta
compute		sum_storeforce_zbottom_before_z all reduce sum f_storeforce_zbottom_before[3]
# compute total force on particles after zbottom apply 
variable	storeforce_zbottom_after_r atom (f_storeforce_zbottom_after[1]*x+f_storeforce_zbottom_after[2]*y)/sqrt(x*x+y*y)
variable	storeforce_zbottom_after_theta atom (f_storeforce_zbottom_after[1]*(-y)+f_storeforce_zbottom_after[2]*x)/sqrt(x*x+y*y)
compute		sum_storeforce_zbottom_after_r all reduce sum v_storeforce_zbottom_after_r
compute		sum_storeforce_zbottom_after_theta all reduce sum v_storeforce_zbottom_after_theta
compute		sum_storeforce_zbottom_after_z all reduce sum f_storeforce_zbottom_after[3]
# total force all atoms on zbottom by substract 
variable	force_zbottom_2 equal c_sum_storeforce_zbottom_after_r-c_sum_storeforce_zbottom_before_r
variable	force_zbottom_1 equal c_sum_storeforce_zbottom_after_theta-c_sum_storeforce_zbottom_before_theta
variable	force_zbottom_3 equal c_sum_storeforce_zbottom_after_z-c_sum_storeforce_zbottom_before_z
label end_bottom_force_cy
jump SELF end_bottom_force
label end_bottom_force
label skip_ave_wall1
#
#variable	fr_in equal c_sumupfr_in-c_sumupfr_no
#variable	fr_out equal c_sumupfr_in_out-c_sumupfr_in
#variable	fr_zplane equal c_sumupfr_in_out_zplane-c_sumupfr_in_out
#variable	ftheta_in equal c_sumupftheta_in-c_sumupftheta_no
#variable	ftheta_out equal c_sumupftheta_in_out-c_sumupftheta_in
#variable	ftheta_zplane equal c_sumupftheta_in_out_zplane-c_sumupftheta_in_out
#variable	fz_in equal c_sumupfz_in-c_sumupfz_no
#variable	fz_out equal c_sumupfz_in_out-c_sumupfz_in
#variable	fz_zplane equal c_sumupfz_in_out_zplane-c_sumupfz_in_out

compute		KEt ${storeforcegroup} ke
compute		KEr ${storeforcegroup} erotate/sphere
variable	KEtr equal "ke + c_KEr"
variable	EKP equal "ke + c_KEr + pe"
# compute
compute		n_contact all contact/atom
compute		KEt_atom ${storeforcegroup} ke/atom
compute		KEr_atom ${storeforcegroup} erotate/sphere/atom
variable	KEtr_atom atom "c_KEt_atom + c_KEr_atom"
compute		PE_atom ${storeforcegroup} pe/atom
variable        EKP_atom atom "c_KEt_atom + c_KEr_atom + c_PE_atom"

# compute id
compute         id_atom ${storeforcegroup} property/atom id

# compute specific atom id by reduce
compute		id_maxKEt ${storeforcegroup} reduce max c_id_atom c_KEt_atom replace 1 2
compute		id_maxKEr ${storeforcegroup} reduce max c_id_atom c_KEr_atom replace 1 2
compute		id_maxKEtr ${storeforcegroup} reduce max c_id_atom v_KEtr_atom replace 1 2

# initially define trace id
variable	check_nbid1 atom false
variable	check_nbid2 atom false
variable	check_nbid3 atom false
variable	check_nbmaxKEt atom false
variable	check_nbmaxKEr atom false
variable	check_nbmaxKEtr atom false

# trace id maxKEt
if "${iftrace_maxKEt} == no" then &
  "jump SELF end_tracemaxKEt"
## define trace group, single atom or region near an atom
variable	trace_id_maxKEt equal c_id_maxKEt[1]
variable	check_nbmaxKEt atom " (x-x[v_trace_id_maxKEt] )^2 + (y-y[v_trace_id_maxKEt] )^2 + (z-z[v_trace_id_maxKEt] )^2 < v_cutoff_dumpnb^2 "
label		end_tracemaxKEt

# trace id maxKEr
if "${iftrace_maxKEr} == no" then &
  "jump SELF end_tracemaxKEr"
## define trace group, single atom or region near an atom
variable	trace_id_maxKEr equal c_id_maxKEr[1]
variable	check_nbmaxKEr atom " (x-x[v_trace_id_maxKEr] )^2 + (y-y[v_trace_id_maxKEr] )^2 + (z-z[v_trace_id_maxKEr] )^2 < v_cutoff_dumpnb^2 "
label		end_tracemaxKEr

# trace id maxKEtr
if "${iftrace_maxKEtr} == no" then &
  "jump SELF end_tracemaxKEtr"
## define trace group, single atom or region near an atom
variable	trace_id_maxKEtr equal c_id_maxKEtr[1]
variable	check_nbmaxKEtr atom " (x-x[v_trace_id_maxKEtr] )^2 + (y-y[v_trace_id_maxKEtr] )^2 + (z-z[v_trace_id_maxKEtr] )^2 < v_cutoff_dumpnb^2 "
label		end_tracemaxKEtr

# trace id1 
if "${trace_id1} == 0" then &
  "jump SELF end_traceid1"
## define trace group, single atom or region near an atom
variable	check_nbid1 atom " (x-x[v_trace_id1] )^2 + (y-y[v_trace_id1] )^2 + (z-z[v_trace_id1] )^2 < v_cutoff_dumpnb^2 "
label		end_traceid1
# trace id2 
if "${trace_id2} == 0" then &
  "jump SELF end_traceid2"
## define trace group, single atom or region near an atom
variable	check_nbid2 atom " (x-x[v_trace_id2] )^2 + (y-y[v_trace_id2] )^2 + (z-z[v_trace_id2] )^2 < v_cutoff_dumpnb^2 "
label		end_traceid2
# trace id3
if "${trace_id3} == 0" then &
  "jump SELF end_traceid3"
## define trace group, single atom or region near an atom
variable	check_nbid3 atom " (x-x[v_trace_id3] )^2 + (y-y[v_trace_id3] )^2 + (z-z[v_trace_id3] )^2 < v_cutoff_dumpnb^2 "
label		end_traceid3

# file, store variable of trace particle by fix vector and output by fix ave/time
if "${freq_fixvector} == 0" then "jump SELF skip_fixvector"
fix		vector_manytime ${storeforcegroup} vector ${every_fixvector} v_trace_id #z[${trace_id}] vz[${trace_id}] fz[${trace_id}] c_n_contact[${trace_id}]
variable	fixvector vector f_vector_manytime
if "${freq_fixvector} == 0" then "jump SELF skip_fixvector"
fix		manytime ${storeforcegroup} ave/time 1 1 ${freq_fixvector} v_fixvector mode vector file output/trace/fix.trace.allstep
label skip_fixvector

# compute for output
if "${freq_print_trace} == 0" then "jump SELF skip_print_trace"
compute radius ${storeforcegroup} property/atom radius
compute omegax ${storeforcegroup} property/atom omegax
compute omegay ${storeforcegroup} property/atom omegay
compute omegaz ${storeforcegroup} property/atom omegaz
compute tqx ${storeforcegroup} property/atom tqx
compute tqy ${storeforcegroup} property/atom tqy
compute tqz ${storeforcegroup} property/atom tqz
# print time and step
fix print_step all print ${freq_print_trace} "$(step)" screen no append output/trace/step
fix print_time all print ${freq_print_trace} "$(time)" screen no append output/trace/time

# file print trace atom_maxKEt
if "${iftrace_maxKEt} == no" then "jump SELF skip_print_trace_maxKEt"

variable print_trace_maxKEt_scalar_id equal v_trace_id_maxKEt
variable print_trace_maxKEt_scalar_type equal type[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_radius equal c_radius[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_x equal x[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_y equal y[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_z equal z[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_vx equal vx[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_vy equal vy[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_vz equal vz[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_fx equal fx[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_fy equal fy[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_fz equal fz[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_omegax equal c_omegax[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_omegay equal c_omegay[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_omegaz equal c_omegaz[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_tqx equal c_tqx[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_tqy equal c_tqy[v_trace_id_maxKEt]
variable print_trace_maxKEt_scalar_tqz equal c_tqz[v_trace_id_maxKEt]


fix print_maxKEt_id ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_id)" screen no append output/trace/maxKEt/id
fix print_maxKEt_type ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_type)" screen no append output/trace/maxKEt/type
fix print_maxKEt_radius ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_radius)" screen no append output/trace/maxKEt/radius
fix print_maxKEt_c_KEt_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_c_KEt_atom)" screen no append output/trace/maxKEt/c_KEt_atom
fix print_maxKEt_c_KEr_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_c_KEr_atom)" screen no append output/trace/maxKEt/c_KEr_atom
fix print_maxKEt_x ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_x)" screen no append output/trace/maxKEt/x
fix print_maxKEt_y ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_y)" screen no append output/trace/maxKEt/y
fix print_maxKEt_z ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_z)" screen no append output/trace/maxKEt/z
fix print_maxKEt_vx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_vx)" screen no append output/trace/maxKEt/vx
fix print_maxKEt_vy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_vy)" screen no append output/trace/maxKEt/vy
fix print_maxKEt_vz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_vz)" screen no append output/trace/maxKEt/vz
fix print_maxKEt_fx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_fx)" screen no append output/trace/maxKEt/fx
fix print_maxKEt_fy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_fy)" screen no append output/trace/maxKEt/fy
fix print_maxKEt_fz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_fz)" screen no append output/trace/maxKEt/fz
fix print_maxKEt_omegax ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_omegax)" screen no append output/trace/maxKEt/omegax
fix print_maxKEt_omegay ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_omegay)" screen no append output/trace/maxKEt/omegay
fix print_maxKEt_omegaz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_omegaz)" screen no append output/trace/maxKEt/omegaz
fix print_maxKEt_tqx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_tqx)" screen no append output/trace/maxKEt/tqx
fix print_maxKEt_tqy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_tqy)" screen no append output/trace/maxKEt/tqy
fix print_maxKEt_tqz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEt_scalar_tqz)" screen no append output/trace/maxKEt/tqz

label skip_print_trace_maxKEt

# file print trace atom_maxKEr
if "${iftrace_maxKEr} == no" then "jump SELF skip_print_trace_maxKEr"

variable print_trace_maxKEr_scalar_id equal v_trace_id_maxKEr
variable print_trace_maxKEr_scalar_type equal type[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_radius equal c_radius[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_x equal x[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_y equal y[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_z equal z[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_vx equal vx[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_vy equal vy[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_vz equal vz[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_fx equal fx[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_fy equal fy[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_fz equal fz[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_omegax equal c_omegax[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_omegay equal c_omegay[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_omegaz equal c_omegaz[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_tqx equal c_tqx[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_tqy equal c_tqy[v_trace_id_maxKEr]
variable print_trace_maxKEr_scalar_tqz equal c_tqz[v_trace_id_maxKEr]


fix print_maxKEr_id ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_id)" screen no append output/trace/maxKEr/id
fix print_maxKEr_type ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_type)" screen no append output/trace/maxKEr/type
fix print_maxKEr_radius ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_radius)" screen no append output/trace/maxKEr/radius
fix print_maxKEr_c_KEt_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_c_KEt_atom)" screen no append output/trace/maxKEr/c_KEt_atom
fix print_maxKEr_c_KEr_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_c_KEr_atom)" screen no append output/trace/maxKEr/c_KEr_atom
fix print_maxKEr_x ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_x)" screen no append output/trace/maxKEr/x
fix print_maxKEr_y ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_y)" screen no append output/trace/maxKEr/y
fix print_maxKEr_z ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_z)" screen no append output/trace/maxKEr/z
fix print_maxKEr_vx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_vx)" screen no append output/trace/maxKEr/vx
fix print_maxKEr_vy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_vy)" screen no append output/trace/maxKEr/vy
fix print_maxKEr_vz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_vz)" screen no append output/trace/maxKEr/vz
fix print_maxKEr_fx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_fx)" screen no append output/trace/maxKEr/fx
fix print_maxKEr_fy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_fy)" screen no append output/trace/maxKEr/fy
fix print_maxKEr_fz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_fz)" screen no append output/trace/maxKEr/fz
fix print_maxKEr_omegax ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_omegax)" screen no append output/trace/maxKEr/omegax
fix print_maxKEr_omegay ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_omegay)" screen no append output/trace/maxKEr/omegay
fix print_maxKEr_omegaz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_omegaz)" screen no append output/trace/maxKEr/omegaz
fix print_maxKEr_tqx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_tqx)" screen no append output/trace/maxKEr/tqx
fix print_maxKEr_tqy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_tqy)" screen no append output/trace/maxKEr/tqy
fix print_maxKEr_tqz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEr_scalar_tqz)" screen no append output/trace/maxKEr/tqz

label skip_print_trace_maxKEr

# file print trace atom_maxKEtr
if "${iftrace_maxKEtr} == no" then "jump SELF skip_print_trace_maxKEtr"

variable print_trace_maxKEtr_scalar_id equal v_trace_id_maxKEtr
variable print_trace_maxKEtr_scalar_type equal type[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_radius equal c_radius[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_x equal x[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_y equal y[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_z equal z[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_vx equal vx[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_vy equal vy[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_vz equal vz[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_fx equal fx[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_fy equal fy[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_fz equal fz[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_omegax equal c_omegax[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_omegay equal c_omegay[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_omegaz equal c_omegaz[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_tqx equal c_tqx[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_tqy equal c_tqy[v_trace_id_maxKEtr]
variable print_trace_maxKEtr_scalar_tqz equal c_tqz[v_trace_id_maxKEtr]


fix print_maxKEtr_id ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_id)" screen no append output/trace/maxKEtr/id
fix print_maxKEtr_type ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_type)" screen no append output/trace/maxKEtr/type
fix print_maxKEtr_radius ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_radius)" screen no append output/trace/maxKEtr/radius
fix print_maxKEtr_c_KEt_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_c_KEt_atom)" screen no append output/trace/maxKEtr/c_KEt_atom
fix print_maxKEtr_c_KEr_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_c_KEr_atom)" screen no append output/trace/maxKEtr/c_KEr_atom
fix print_maxKEtr_x ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_x)" screen no append output/trace/maxKEtr/x
fix print_maxKEtr_y ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_y)" screen no append output/trace/maxKEtr/y
fix print_maxKEtr_z ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_z)" screen no append output/trace/maxKEtr/z
fix print_maxKEtr_vx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_vx)" screen no append output/trace/maxKEtr/vx
fix print_maxKEtr_vy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_vy)" screen no append output/trace/maxKEtr/vy
fix print_maxKEtr_vz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_vz)" screen no append output/trace/maxKEtr/vz
fix print_maxKEtr_fx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_fx)" screen no append output/trace/maxKEtr/fx
fix print_maxKEtr_fy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_fy)" screen no append output/trace/maxKEtr/fy
fix print_maxKEtr_fz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_fz)" screen no append output/trace/maxKEtr/fz
fix print_maxKEtr_omegax ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_omegax)" screen no append output/trace/maxKEtr/omegax
fix print_maxKEtr_omegay ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_omegay)" screen no append output/trace/maxKEtr/omegay
fix print_maxKEtr_omegaz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_omegaz)" screen no append output/trace/maxKEtr/omegaz
fix print_maxKEtr_tqx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_tqx)" screen no append output/trace/maxKEtr/tqx
fix print_maxKEtr_tqy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_tqy)" screen no append output/trace/maxKEtr/tqy
fix print_maxKEtr_tqz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_maxKEtr_scalar_tqz)" screen no append output/trace/maxKEtr/tqz

label skip_print_trace_maxKEtr


# file print trace atom_1
if "${trace_id1} == 0" then "jump SELF skip_print_trace_1"

variable print_trace_1_scalar_id equal v_trace_id1
variable print_trace_1_scalar_type equal type[v_trace_id1]
variable print_trace_1_scalar_radius equal c_radius[v_trace_id1]
variable print_trace_1_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id1]
variable print_trace_1_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id1]
variable print_trace_1_scalar_x equal x[v_trace_id1]
variable print_trace_1_scalar_y equal y[v_trace_id1]
variable print_trace_1_scalar_z equal z[v_trace_id1]
variable print_trace_1_scalar_vx equal vx[v_trace_id1]
variable print_trace_1_scalar_vy equal vy[v_trace_id1]
variable print_trace_1_scalar_vz equal vz[v_trace_id1]
variable print_trace_1_scalar_fx equal fx[v_trace_id1]
variable print_trace_1_scalar_fy equal fy[v_trace_id1]
variable print_trace_1_scalar_fz equal fz[v_trace_id1]
variable print_trace_1_scalar_omegax equal c_omegax[v_trace_id1]
variable print_trace_1_scalar_omegay equal c_omegay[v_trace_id1]
variable print_trace_1_scalar_omegaz equal c_omegaz[v_trace_id1]
variable print_trace_1_scalar_tqx equal c_tqx[v_trace_id1]
variable print_trace_1_scalar_tqy equal c_tqy[v_trace_id1]
variable print_trace_1_scalar_tqz equal c_tqz[v_trace_id1]

fix print_1_id ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_id)" screen no append output/trace/${trace_id1}/id
fix print_1_type ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_type)" screen no append output/trace/${trace_id1}/type
fix print_1_radius ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_radius)" screen no append output/trace/${trace_id1}/radius
fix print_1_c_KEt_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_c_KEt_atom)" screen no append output/trace/${trace_id1}/c_KEt_atom
fix print_1_c_KEr_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_c_KEr_atom)" screen no append output/trace/${trace_id1}/c_KEr_atom
fix print_1_x ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_x)" screen no append output/trace/${trace_id1}/x
fix print_1_y ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_y)" screen no append output/trace/${trace_id1}/y
fix print_1_z ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_z)" screen no append output/trace/${trace_id1}/z
fix print_1_vx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_vx)" screen no append output/trace/${trace_id1}/vx
fix print_1_vy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_vy)" screen no append output/trace/${trace_id1}/vy
fix print_1_vz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_vz)" screen no append output/trace/${trace_id1}/vz
fix print_1_fx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_fx)" screen no append output/trace/${trace_id1}/fx
fix print_1_fy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_fy)" screen no append output/trace/${trace_id1}/fy
fix print_1_fz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_fz)" screen no append output/trace/${trace_id1}/fz
fix print_1_omegax ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_omegax)" screen no append output/trace/${trace_id1}/omegax
fix print_1_omegay ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_omegay)" screen no append output/trace/${trace_id1}/omegay
fix print_1_omegaz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_omegaz)" screen no append output/trace/${trace_id1}/omegaz
fix print_1_tqx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_tqx)" screen no append output/trace/${trace_id1}/tqx
fix print_1_tqy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_tqy)" screen no append output/trace/${trace_id1}/tqy
fix print_1_tqz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_1_scalar_tqz)" screen no append output/trace/${trace_id1}/tqz

label skip_print_trace_1


# file print trace atom_2
if "${trace_id2} == 0" then "jump SELF skip_print_trace_2"

variable print_trace_2_scalar_id equal v_trace_id2
variable print_trace_2_scalar_type equal type[v_trace_id2]
variable print_trace_2_scalar_radius equal c_radius[v_trace_id2]
variable print_trace_2_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id2]
variable print_trace_2_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id2]
variable print_trace_2_scalar_x equal x[v_trace_id2]
variable print_trace_2_scalar_y equal y[v_trace_id2]
variable print_trace_2_scalar_z equal z[v_trace_id2]
variable print_trace_2_scalar_vx equal vx[v_trace_id2]
variable print_trace_2_scalar_vy equal vy[v_trace_id2]
variable print_trace_2_scalar_vz equal vz[v_trace_id2]
variable print_trace_2_scalar_fx equal fx[v_trace_id2]
variable print_trace_2_scalar_fy equal fy[v_trace_id2]
variable print_trace_2_scalar_fz equal fz[v_trace_id2]
variable print_trace_2_scalar_omegax equal c_omegax[v_trace_id2]
variable print_trace_2_scalar_omegay equal c_omegay[v_trace_id2]
variable print_trace_2_scalar_omegaz equal c_omegaz[v_trace_id2]
variable print_trace_2_scalar_tqx equal c_tqx[v_trace_id2]
variable print_trace_2_scalar_tqy equal c_tqy[v_trace_id2]
variable print_trace_2_scalar_tqz equal c_tqz[v_trace_id2]

fix print_2_id ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_id)" screen no append output/trace/${trace_id2}/id
fix print_2_type ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_type)" screen no append output/trace/${trace_id2}/type
fix print_2_radius ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_radius)" screen no append output/trace/${trace_id2}/radius
fix print_2_c_KEt_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_c_KEt_atom)" screen no append output/trace/${trace_id2}/c_KEt_atom
fix print_2_c_KEr_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_c_KEr_atom)" screen no append output/trace/${trace_id2}/c_KEr_atom
fix print_2_x ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_x)" screen no append output/trace/${trace_id2}/x
fix print_2_y ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_y)" screen no append output/trace/${trace_id2}/y
fix print_2_z ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_z)" screen no append output/trace/${trace_id2}/z
fix print_2_vx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_vx)" screen no append output/trace/${trace_id2}/vx
fix print_2_vy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_vy)" screen no append output/trace/${trace_id2}/vy
fix print_2_vz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_vz)" screen no append output/trace/${trace_id2}/vz
fix print_2_fx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_fx)" screen no append output/trace/${trace_id2}/fx
fix print_2_fy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_fy)" screen no append output/trace/${trace_id2}/fy
fix print_2_fz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_fz)" screen no append output/trace/${trace_id2}/fz
fix print_2_omegax ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_omegax)" screen no append output/trace/${trace_id2}/omegax
fix print_2_omegay ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_omegay)" screen no append output/trace/${trace_id2}/omegay
fix print_2_omegaz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_omegaz)" screen no append output/trace/${trace_id2}/omegaz
fix print_2_tqx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_tqx)" screen no append output/trace/${trace_id2}/tqx
fix print_2_tqy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_tqy)" screen no append output/trace/${trace_id2}/tqy
fix print_2_tqz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_2_scalar_tqz)" screen no append output/trace/${trace_id2}/tqz

label skip_print_trace_2


# file print trace atom_3
if "${trace_id3} == 0" then "jump SELF skip_print_trace_3"

variable print_trace_3_scalar_id equal v_trace_id3
variable print_trace_3_scalar_type equal type[v_trace_id3]
variable print_trace_3_scalar_radius equal c_radius[v_trace_id3]
variable print_trace_3_scalar_c_KEt_atom equal c_KEt_atom[v_trace_id3]
variable print_trace_3_scalar_c_KEr_atom equal c_KEr_atom[v_trace_id3]
variable print_trace_3_scalar_x equal x[v_trace_id3]
variable print_trace_3_scalar_y equal y[v_trace_id3]
variable print_trace_3_scalar_z equal z[v_trace_id3]
variable print_trace_3_scalar_vx equal vx[v_trace_id3]
variable print_trace_3_scalar_vy equal vy[v_trace_id3]
variable print_trace_3_scalar_vz equal vz[v_trace_id3]
variable print_trace_3_scalar_fx equal fx[v_trace_id3]
variable print_trace_3_scalar_fy equal fy[v_trace_id3]
variable print_trace_3_scalar_fz equal fz[v_trace_id3]
variable print_trace_3_scalar_omegax equal c_omegax[v_trace_id3]
variable print_trace_3_scalar_omegay equal c_omegay[v_trace_id3]
variable print_trace_3_scalar_omegaz equal c_omegaz[v_trace_id3]
variable print_trace_3_scalar_tqx equal c_tqx[v_trace_id3]
variable print_trace_3_scalar_tqy equal c_tqy[v_trace_id3]
variable print_trace_3_scalar_tqz equal c_tqz[v_trace_id3]

fix print_3_id ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_id)" screen no append output/trace/${trace_id3}/id
fix print_3_type ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_type)" screen no append output/trace/${trace_id3}/type
fix print_3_radius ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_radius)" screen no append output/trace/${trace_id3}/radius
fix print_3_c_KEt_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_c_KEt_atom)" screen no append output/trace/${trace_id3}/c_KEt_atom
fix print_3_c_KEr_atom ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_c_KEr_atom)" screen no append output/trace/${trace_id3}/c_KEr_atom
fix print_3_x ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_x)" screen no append output/trace/${trace_id3}/x
fix print_3_y ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_y)" screen no append output/trace/${trace_id3}/y
fix print_3_z ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_z)" screen no append output/trace/${trace_id3}/z
fix print_3_vx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_vx)" screen no append output/trace/${trace_id3}/vx
fix print_3_vy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_vy)" screen no append output/trace/${trace_id3}/vy
fix print_3_vz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_vz)" screen no append output/trace/${trace_id3}/vz
fix print_3_fx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_fx)" screen no append output/trace/${trace_id3}/fx
fix print_3_fy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_fy)" screen no append output/trace/${trace_id3}/fy
fix print_3_fz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_fz)" screen no append output/trace/${trace_id3}/fz
fix print_3_omegax ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_omegax)" screen no append output/trace/${trace_id3}/omegax
fix print_3_omegay ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_omegay)" screen no append output/trace/${trace_id3}/omegay
fix print_3_omegaz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_omegaz)" screen no append output/trace/${trace_id3}/omegaz
fix print_3_tqx ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_tqx)" screen no append output/trace/${trace_id3}/tqx
fix print_3_tqy ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_tqy)" screen no append output/trace/${trace_id3}/tqy
fix print_3_tqz ${storeforcegroup} print ${freq_print_trace} "$(v_print_trace_3_scalar_tqz)" screen no append output/trace/${trace_id3}/tqz

label skip_print_trace_3

label skip_print_trace

variable	check_nb_all atom v_check_nbid1||v_check_nbid2||v_check_nbid3||v_check_nbmaxKEt||v_check_nbmaxKEr||v_check_nbmaxKEtr
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour3"
run 1
label	end_pour3
if "${ifdeposit} == no || ${rst_from} != 0" then "jump SELF end_deposit2"
run 1
label	end_deposit2
group 		group_nb_all dynamic ${storeforcegroup} var check_nb_all every 1

# file dump custom trace atoms
if "${freq_dump_single_trace} == 0" then "jump SELF skip_dump_single_trace"
dump		dump_trace group_nb_all custom ${freq_dump_single_trace} output/single_trace/dump.trace.single.* &
id type radius c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz v_EKP_atom c_n_contact v_check_nb_all v_KEtr_atom &
f_sum_pairforce[*]
dump_modify     dump_trace format float %.16g
label skip_dump_single_trace
# file, dump custom all atoms
if "${freq_dump_single_all} == 0" then "jump SELF skip_dump_all_custom"
dump		dump_all ${storeforcegroup} custom ${freq_dump_single_all} output/single_all/dump.all.single.* &
id type radius c_KEt_atom c_KEr_atom x y z vx vy vz fx fy fz omegax omegay omegaz tqx tqy tqz v_EKP_atom c_n_contact v_check_nb_all v_KEtr_atom &
f_sum_pairforce[*]
dump_modify	dump_all format float %.16g maxfiles ${n_maxfile_single_all}
label skip_dump_all_custom

# compute and output pair trace atoms
if "${freq_dump_pair_trace} == 0" then "jump SELF skip_dump_pair_trace"
compute		p_idtype_trace group_nb_all property/local patom1 patom2 ptype1 ptype2	#id_I id_J type_I type_J
compute		p_fv_trace group_nb_all pair/local dist fx fy fz force p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 	#p1,p2,p3,ft component. p4 ft magnitude. p5 p6 p7 vn. p8 p9 p10 vt. Force acting on I atom. Velocity is vi-vj
# file, pair trace atoms
dump		dump_pair_trace group_nb_all local ${freq_dump_pair_trace} output/pair_trace/dump.trace.pair.* index c_p_idtype_trace[*] c_p_fv_trace[*]
dump_modify     dump_pair_trace format float %.16g
label skip_dump_pair_trace

# compute pair all atoms
if "${freq_dump_pair_all} == 0" then "jump SELF skip_dump_pair_all"
compute		p_idtype_all all property/local patom1 patom2 ptype1 ptype2	#id_I id_J type_I type_J
compute		p_fv_all all pair/local dist fx fy fz force p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 	#p1,p2,p3,ft component. p4 ft magnitude. p5 p6 p7 vn. p8 p9 p10 vt. Force acting on I atom. Velocity is vi-vj
# file, pair all atoms
dump		dump_pair_all all local ${freq_dump_pair_all} output/pair_all/dump.all.pair.* index c_p_idtype_all[*] c_p_fv_all[*]
dump_modify     dump_pair_all format float %.16g
label skip_dump_pair_all

#file, image jpg trace atoms
if "${freq_dump_trace_image} == 0" then "jump SELF skip_dump_trace_image"
dump		dump_image_trace group_nb_all image ${freq_dump_trace_image} output/image/trace/dump.trace_image.*.jpg type diameter size 512 512 zoom 1
label skip_dump_trace_image

#file, image jpg all atoms
if "${freq_dump_all_image} == 0" then "jump SELF skip_dump_all_image"
dump		dump_image_all all image ${freq_dump_all_image} output/image/all/all_image_*.jpg type diameter size 512 512 zoom 1
label skip_dump_all_image

#file, movie, have not work
if "${freq_dump_all_movie} == 0" then "jump SELF skip_dump_all_movie"
dump   m0 all movie ${freq_dump_movie} output/movie/movie.allstep.m4v type type size 640 480
label skip_dump_all_movie

#file, vtk
if "${freq_dump_all_vtk} == 0" then "jump SELF skip_dump_all_vtk"
dump            dmpatom all atom/vtk ${freq_dump_vtk} vtk/atom.*.vtk
label skip_dump_all_vtk

#file, stl
if "${freq_dump_all_stl} == 0" then "jump SELF skip_dump_all_stl"
dump            dmpstl1 all mesh/stl ${freq_dump_stl} stl/in*.stl cad1
dump            dmpstl2 all mesh/stl ${freq_dump_stl} stl/out*.stl cad2
label skip_dump_all_stl

variable  ke_per_atom   equal   ke/atoms
# file, thermo
if "${iftrace_maxKEt} == yes" then &
"thermo_style	custom step time vol atoms ke v_ke_per_atom c_KEr pe v_KEtr v_EKP c_id_maxKEt[1] c_id_maxKEt[2]" &
else &
"thermo_style	custom step time vol atoms ke v_ke_per_atom c_KEr pe v_KEtr v_EKP"
thermo_modify   lost ${thermo_lost_error_or_warn} norm no
if "${freq_thermo} == 0" then "jump SELF skip_thermo"
thermo		${freq_thermo} #${freq_thermo} v_freq_thermo #
label skip_thermo

# ifcondition meet than stop
if "${freq_check_condition_exit} == -1" then &
"jump SELF skip_check_condition_exit"
variable set_condition equal "(v_ke_per_atom < v_ke_per_atom_check) && (step > 1000)"   
fix checkhalt ${storeforcegroup} halt ${freq_check_condition_exit} v_set_condition == 1.0
label skip_check_condition_exit

# file, restart file
if "${freq_restart_big} == 0" then "jump SELF skip_restart_big"
restart		${freq_restart_big} output/rst/restart.mpiio.*
label skip_restart_big
if "${freq_restart_small} == 0" then "jump SELF skip_restart_small"
restart		${freq_restart_small} output/rst/restart.mpiio.tmp1 output/rst/restart.mpiio.tmp2
label skip_restart_small

# run pour and delete and add inner wall
if "${ifpour} == no || ${rst_from} != 0" then "jump SELF end_pour2_innerwall"
run 10
if "${boundary_geometry} == block" then &
  "region       	delete_in_small block 0 ${xhi_box} ${ylo_create} ${yhi_create} 0 ${zhi_box} units box" &
elif "${boundary_geometry} == cylinder" &
  "region       	delete_in_small cylinder z 0. 0. ${ri_create} ${zlo_box} ${zhi_box} units box" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
delete_atoms 	region delete_in_small

fix	storeforce_inwall_before	${storeforcegroup} store/force
if "${if_inwall_wall_gran} != no" then &
  "jump SELF ybottom_wall_flat_end2"
# fix inwall
label begin_fixinwall
if "${boundary_geometry} == block" then &
  "jump SELF begin_fixinwall_block" &
elif "${boundary_geometry} == cylinder" &
  "jump SELF begin_fixinwall_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# block
label begin_fixinwall_block
if "${ifrotate} == yes" then &
  "fix	inwall		${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} yplane ${ylo_wall} NULL shear x ${in_velocity}" &
else &
  "fix	inwall		${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} yplane ${ylo_wall} NULL"
label end_fixinwall_block
jump SELF end_fixinwall
# cylinder
label begin_fixinwall_cy
if "${ifrotate} == yes" then &
  "fix	inwall		${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri_wall} shear x ${in_velocity_negative}" &
else &
  "fix	inwall		${storeforcegroup} wall/gran ${contact_model_wall_string} ${kn} ${kt} ${gamma_n} ${gamma_t} ${xmu} ${ifdamp_tangent} zcylinder ${ri_wall}"
label end_fixinwall_cy
jump SELF end_fixinwall
label end_fixinwall

fix	storeforce_inwall_after	all store/force
label ybottom_wall_flat_end2
label	end_pour2_innerwall
# file,  time average of total force of wall to particles
label begin_timeaverage
if "${boundary_geometry} == block" then &
  "jump SELF begin_timeaverage_block" &
elif "${boundary_geometry} == cylinder" &
  "jump SELF begin_timeaverage_cy" &
else &
  "print 'boundary_geometry not block not cylinder'" &
  "quit 1"
# block
label begin_timeaverage_block
fix		timeav_inwall_force ${storeforcegroup} ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} &
v_t &
v_force_inwall_1 v_force_inwall_2 v_force_inwall_3 &
mode scalar ave one file output/wall/force_y_bottom_to_particle.allstep
fix		timeav_outwall_force ${storeforcegroup} ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} &
v_t &
v_force_outwall_1 v_force_outwall_2 v_force_outwall_3 &
mode scalar ave one file output/wall/force_y_top_to_particle.allstep
fix		timeav_zbottom_force ${storeforcegroup} ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} &
v_t &
v_force_zbottom_1 v_force_zbottom_2 v_force_zbottom_3 &
mode scalar ave one file output/wall/force_zbottom_to_particle.allstep
label end_timeaverage_block
jump SELF end_timeaverage
# cylinder
label begin_timeaverage_cy
fix		timeav_inwall_force all ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} &
v_t &
v_force_inwall_1 v_force_inwall_2 v_force_inwall_3 &
mode scalar ave one file output/wall/force_inwall_to_particle.allstep
fix		timeav_outwall_force all ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} &
v_t &
v_force_outwall_1 v_force_outwall_2 v_force_outwall_3 &
mode scalar ave one file output/wall/force_outwall_to_particle.allstep
fix		timeav_zbottom_force all ave/time ${every_ave_wall} ${repeat_ave_wall} ${freq_ave_wall} &
v_t &
v_force_zbottom_1 v_force_zbottom_2 v_force_zbottom_3 &
mode scalar ave one file output/wall/force_zbottom_to_particle.allstep
label end_timeaverage_cy
jump SELF end_timeaverage
label end_timeaverage


label skip_ave_wall2

# ybottom_wall freeze, need restart
if "${if_inwall_wall_gran} == no" then &
  "jump SELF ybottom_wall_gran_end2"
label ybottom_wall_gran_begin2
fix     freeze_ybottom_wall near_ybottom_wall_gran freeze
label ybottom_wall_gran_end2
# balance every freq_balance step
if "${freq_balance} == 0" then "jump SELF skip_balance1"
#balance 	1.0 shift yz 100 1.05
fix balance1 all balance ${freq_balance} 1.02 shift yz 100 1.01 weight time 1.0
label skip_balance1

# run

if "${runstep_loop} == 0" then "jump SELF skip_loop1"
variable a loop ${n_loop}
label loop
run ${runstep_loop}
if "$(c_id_maxKEt[2]) < ${KEtr_to_jumpout}" then "jump SELF break1"
next a
jump SELF loop
label break1
print "Loop condition satisfied"
label skip_loop1

if "${runstep_loop} != 0" then "jump SELF skip_run1"
run ${runstep}
label skip_run1
